 DIGITAL NOTES
ON
DIGITAL LOGIC DESIGN
B.TECH II YEAR - I SEM
(2018-19)
Y COLLEGE OF ENGINEERING &
& TECH
LIVE TO LEARN & LEARN TO SHARE
DEPARTMENT OF INFORMATION TECHNOLOGY
MALLA REDDY COLLEGE OF ENGINEERING & TECHNOLOGY
(Autonomous Institution - UGC, Govt. of India)
(Affiliated to JNTUH, Hyderabad, Approved by AICTE - Accredited by NBA & NAAC - 'A' Grade - ISO 9001:2015 Certified)
Maisammaguda, Dhulapally (Post Via. Hakimpet), Secunderabad - 500100, Telangana State, INDIA.LINE TO LEARN & LEARN TO SHARE
●
OBJECTIVES
This course provides in-depth knowledge of switching theory and the logic design techniques
of digital circuits, which is the basis for design of any digital circuit. The course objectives are:
●
●
●
●
MALLA REDDY COLLEGE OF ENGINEERING & TECHNOLOGY
DEPARTMENT OF INFORMATION TECHNOLOGY
●
(SYLLABUS)
To learn basic techniques for the design of digital circuits and fundamental concepts
used in the design of digital systems.
To understand common forms of number representation in digital electronic circuits and
to be able to convert between different representations.
To implement simple logical operations using combinational logic circuits
To design combinational logic circuits, sequential logic circuits.
To impart to student the concepts of sequential circuits, enabling them to analyze
sequential systems in terms of state machines.
To implement synchronous state machines using flip-flops.
UNIT -I:
Number System and Boolean Algebra :
Number Systems, Base Conversion Methods, Complements of Numbers, Codes- Binary Codes,
Binary Coded Decimal Code and its Properties, Unit Distance Codes, Error Detecting and
Correcting Codes.
Digital Logic Gates(AND,NAND,OR,NOR,EX-OR,EX-NOR), Properties of XOR Gates,
Universal Gates, Basic Theorems and Properties, Switching Functions, Canonical and Standard
Form.
UNIT -II:
Minimization Techniques:
Introduction, The minimization with theorems, The Karnaugh Map Method, Three, Four and
Five variable K- Maps, Prime and Essential Implications, Don't Care Map Entries, Using the
Maps for Simplifying, Quine-McCluskey Method, Multilevel NAND/NOR realizations.
UNIT -III:
Combinational Circuits:
Design Procedure Half Adder, Full Adder, Half Subtractor, Full Subtractor, Parallel Binary
Adder, Parallel binary subtractor, Binary Multiplier, Multiplexers/DeMultiplexers, decoder,
Encoder, Code Converters, Magnitude Comparator.
classification of sequential circuits, The binary cell, The S-R-Latch Flip-Flop The D-Latch
Flip-Flop, The "Clocked T" Flip-Flop, The " Clocked J-K" Flip-Flop, Design of a Clocked
Flip-Flop, Timing and Triggering Consideration.UNIT -IV:
Sequential Circuits:
Introduction, Basic Architectural Distinctions between Combinational and Sequential circuits,
Latches,Flip-Flops, SR,JK,D,T and Master slave, characteristic Tables and equations,
Conversion from one type of Flip-Flop to another,
Counters - Design of Single Mode Counter, Ripple Counter, Ring Counter, Shift Register, Ring
counter using Shift Register
UNIT -V:
Memory Devices:
Clasification of memories ROM ROM organization, PROM, EPROM,EEPROM, RAM:
RAM organization, Write operation, Read operation, Static RAM, Programmable Logic
Devices: Programmable Logic Array(PLA),Programmable Array Logic, Implementaion of
Combinational Logic circuits using ROM,PLA,PAL.
TEXT BOOKS:
1. Digital Design- Morris Mano, PHI, 3rd Edition.
2. Switching Theory and Logic Design-A. Anand Kumar, PHI, 2nd Edition.
3. Switching and Finite Automata Theory- Zvi Kohavi & Niraj K. Jha, 3rd Edition,
Cambridge.
REFERENCE BOOKS:
1. Introduction to Switching Theory and Logic Design – Fredriac J. Hill, Gerald R. Peterson,
3rd Ed.,John Wiley & Sons Inc.
2. Digital Fundamentals A Systems Approach - Thomas L. Floyd, Pearson, 2013.
3. Switching Theory and Logic Design Bhanu Bhaskara -Tata McGraw Hill Publication,
2012
4. Fundamentals of Logic Design- Charles H. Roth, Cengage LEanring, 5th, Edition, 2004.
5. Digital Logic Applications and Design- John M. Yarbrough, Thomson Publications, 2006. 6.
Digital Logic and State Machine Design - Comer, 3rd, Oxford, 2013.
OUTCOMES
Upon completion of the course, student should possess the following skills:
Be able to manipulate numeric information in different forms
Be able to manipulate simple Boolean expressions using the theorems and postulates of
Boolean algebra and to minimize combinational functions.
Be able to design and analyze small combinational circuits and to use standard
combinational functions to build larger more complex circuits.
Be able to design and analyze small sequential circuits and to use standard sequential
functions to build larger more complex circuits.LINE TO LEARN & LEARN TO SHARE
S. No
1
2
3
4
MALLA REDDY COLLEGE OF ENGINEERING & TECHNOLOGY
DEPARTMENT OF INFORMATION TECHNOLOGY
5
Unit
I
II
III
IV
V
INDEX
Topic
NUMBERS SYSTEMS AND BOOLEAN ALGEBRA
MINIMIZATION TECHNIQUES
COMBINATIONAL CIRCUITS
SEQUENTIAL CIRCUITS
MEMORY DEVICES
Page no
01
39
60
89
119●
●
●
●
●
●
LAVE TO LEARN LEARN TO SHARE
INTRODUCTION ABOUT DIGITAL SYSTEM
A Digital system is an interconnection of digital modules and it is a system that manipulates
discrete elements of information that is represented internally in the binary form.
●
MALLA REDDY COLLEGE OF ENGINEERING & TECHNOLOGY
DEPARTMENT OF INFORMATION TECHNOLOGY
Now a day's digital systems are used in wide variety of industrial and consumer products such as
automated industrial machinery, pocket calculators, microprocessors, digital computers, digital watches,
TV games and signal processing and so on.
Characteristics of Digital systems
●
●
UNIT - 1
NUMBER SYSTEMS & BOOLEAN ALGEBRA
Introduction about digital system
Philosophy of number systems
Complement representation of negative numbers
Binary arithmetic
Binary codes
Error detecting & error correcting codes
Hamming codes
Digital systems use physical quantities called signals to represent discrete elements.
In digital systems, the signals have two discrete values and are therefore said to be binary.
A signal in digital system represents one binary digit called a bit. The bit has a value either 0 or 1.
Analog systems vs Digital systems
Analog system process information that varies continuously i.e; they process time varying signals
that can take on any values across a continuous range of voltage, current or any physical parameter.
Digital systems manipulate discrete elements of information.
Discrete elements are nothing but the digits such as 10 decimal digits or 26 letters of alphabets and
so on.
Digital systems use digital circuits that can process digital signals which can take either 0 or 1 for
binary system.
DIGITAL LOGIC DESIGN
Intensity
time
-0.00
1
Abrupt amplitude variations
Intensity
1
1
time'age no. 1Advantages of Digital system over Analog system
1. Ease of programmability
The digital systems can be used for different applications by simply changing the program without
additional changes in hardware.
2. Reduction in cost of hardware
The cost of hardware gets reduced by use of digital components and this has been possible due to
advances in IC technology. With ICs the number of components that can be placed in a given area of
Silicon are increased which helps in cost reduction.
3.High speed
Digital processing of data ensures high speed of operation which is possible due to advances in
Digital Signal Processing.
4. High Reliability
5. Design is easy
Digital systems are highly reliable one of the reasons for that is use of error correction codes.
The design of digital systems which require use of Boolean algebra and other digital techniques is
easier compared to analog designing.
6. Result can be reproduced easily
Since the output of digital systems unlike analog systems is independent of temperature, noise,
humidity and other characteristics of components the reproducibility of results is higher in digital systems
than in analog systems.
Disadvantages of Digital Systems
Use more energy than analog circuits to accomplish the same tasks, thus producing more heat as
well.
●
●
Digital circuits are often fragile, in that if a single piece of digital data is lost or misinterpreted the
meaning of large blocks of related data can completely change.
Digital computer manipulates discrete elements of information by means of a binary code.
Quantization error during analog signal sampling.
DIGITAL LOGIC DESIGN
Page no.NUMBER SYSTEM
Number system is a basis for counting varies items. Modern computers communicate and operate
with binary numbers which use only the digits 0 &1. Basic number system used by humans is Decimal
number system.
For Ex: Let us consider decimal number 18. This number is represented in binary as 10010.
We observe that binary number system take more digits to represent the decimal number. For large
numbers we have to deal with very large binary strings. So this fact gave rise to three new number systems.
●
●
i) Octal number systems
To define any number system we have to specify
ii) Hexa Decimal number system
iii) Binary Coded Decimal number(BCD) system
Base of the number system such as 2,8,10 or 16.
The base decides the total number of digits available in that number system.
●
First digit in the number system is always zero and last digit in the number system is always
base-1.
Binary number system:
The binary number has a radix of 2. As r = 2, only two digits are needed, and these are 0 and 1. In
binary system weight is expressed as power of 2.
Example:
MSB
Figure 2: Binary position values as power of 2
2
2
DIGITAL LOGIC DESIGN
Binary Point
2
2
MSB
The left most bit, which has the greatest weight is called the Most Significant Bit (MSB). And the
right most bit which has the least weight is called Least Significant Bit (LSB).
Page no. 3X
For Ex: 1001.012= [(1) x 2³] + [(0) × 2²] + [(0) × 2¹ ]+[(1) × 2⁰ ] + [(0)×2¹¹] + [
(1)×2²]
1001.012= [1 x 8]+[0x4] + [0×2] + [1 x 1] + [0x0.5 ] + [ 1 x 0.25 ]
1001.012=9.25 10
Decimal Number system
The decimal system has ten symbols: 0,1,2,3,4,5,6,7,8,9. In other words, it has a base of 10.
Octal Number System
Digital systems operate only on binary numbers. Since binary numbers are often very long, two
shorthand notations, octal and hexadecimal, are used for representing large binary numbers. Octal systems
use a base or radix of 8. It uses first eight digits of decimal number system. Thus it has digits from 0 to 7.
Hexa Decimal Number System
The hexadecimal numbering system has a base of 16. There are 16 symbols. The decimal digits 0 to
9 are used as the first ten digits as in the decimal system, followed by the letters A, B, C, D, E and F, which
represent the values 10, 11,12,13,14 and 15 respectively.
DIGITAL LOGIC DESIGN
Decima
1
0
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
Binar Octal
y
0000
0001
0010
0011
0100
0101
0110
0111
1000
1001
1010
1011
1100
1101
1110
1111
0
1
2
3
4
5
6
7
10
11
12
13
14
15
16
17
Hexadeci
mal
0
1
2
3
4
5
6
7
8
9
A
B
CDEF
с
Page no. 4Number Base conversions
The human beings use decimal number system while computer uses binary number system.
Therefore it is necessary to convert decimal number system into its equivalent binary.
i)
ii)
iii)
iv)
v)
Binary to octal number conversion
Binary to hexa decimal number conversion
The binary number:
The octal number:
Octal to binary Conversion
The binary number:
The hexadecimal number: 1 2 5 8 9
Code
0 - 000
1 - 001
2-010
3-011
4 - 100
5-101
6-110
7-111
Each octal number converts to 3 binary digits
To convert 653, to binary, just
substitute code:
Hexa to binary conversion
0100 1111
Octal to Decimal conversion
001 010 011 000 100 101 110 111
-- -
Ex: convert 4057.068 to octal
1 2
DIGITAL LOGIC DESIGN
3 04 5 6 7
0001 0010 0100 1000 1001 1010 1101 1111
= 2048+0+40+7+0+0.0937
6 5 3
Į
110 101 011
1101
=4x8³+0x8²+5x8¹+7x80+0x8-¹+6x8-²
0111
A D F
Page no. 5vi)
vii)
viii)
Decimal to Octal Conversion
=2095.093710
Ex: convert 378.9310 to octal
37810 to octal: Successive division:
81 378
|
8 147
=
16 2598
16 162
10
0.9310 to octal :
8 15
|
0.93x8=7.44
0.44x8=3.52
0.53x8=4.16
0.16x8=1.28
0
A26 (16)
DIGITAL LOGIC DESIGN
===
111
= 5728
-6
-2
=1280+192+7
=0.73418
378.9310 572.73418
Hexadecimal to Decimal Conversion
Ex: 5C716 to decimal
2
7
=14710
Decimal to Hexadecimal Conversion
Ex: 2598.67510
er
=(5x16²)+(C x16¹)+ (7 x16°)
5
↓
↑
Page no. 6ix)
X)
0.67510-0.675x16 -- 10.8
=).800x16 12.8
=0.800x16 -- 12.8
=).800x16 -- 12.8
=0.ACCC16
i)
ii)
2598.67510 A26.ACCC16
Octal to hexadecimal conversion:
Ex: 756.6038
The simplest way is to first convert the given octal no. to binary & then the binary no. to
hexadecimal.
7
111
0001
1
=
Ex: B9F.AE16
Complements:
B
1011
101
5
↓
Hexadecimal to octal conversion:
5
101
1110
E
DIGITAL LOGIC DESIGN
6
110
1110
E
9
1001
110
6
First convert the given hexadecimal no. to binary & then the binary no. to octal.
F
1111
011
3
6
110
111
7
1100
C
A
1010
0
000
The radix complement or r's complement
The diminished radix complement or (r-1)'s complement
0001
1
3
011
E
1110
101
5
1000
8
011
3
In digital computers to simplify the subtraction operation & for logical manipulation complements
are used. There are two types of complements used in each radix system.
=5637.534
100
4
Page no. 7Representation of signed no.s binary arithmetic in computers:
Two ways of rep signed no.s
1. Sign Magnitude form
2. Complemented form
Two complimented forms
1. 1's compliment form
2. 2's compliment form
Advantage of performing subtraction by the compliment method is reduction in the hardware.(
instead of addition & subtraction only adding ckt's are needed.)
i.e, subtraction is also performed by adders only.
●
Instead of subtracting one no. from other the compliment of the subtrahend is added to
minuend. In sign magnitude form, an additional bit called the sign bit is placed in front of the no.
If the sign bit is 0, the no. is +ve, If it is a 1, the no is _ve.
Ex:
Sign bit
Ex:
↑
0
1
1
Given no.
01101
010111
10111
1101010
0
0
1 0 0
1
DIGITAL LOGIC DESIGN
=+41 magnitude
0
= -41
Note: manipulation is necessary to add a +ve no to a -ve no
Representation of signed no.s using 2's or 1's complement method:
If the no. is +ve, the magnitude is rep in its true binary form & a sign bit 0 is placed in
front of the MSB.I f the no is _ve, the magnitude is rep in its 2's or 1's compliment form &a
sign bit 1 is placed in front of the MSB.
0 1
Sign mag form
+13
+23
-7
-42
2's comp form
+13
+23
-7
-22
1's comp form
+13
+23
-8
-21
Page no. 8Special case in 2's comp representation:
Whenever a signed no. has a 1 in the sign bit & all 0's for the magnitude bits, the decimal
equivalent is -2¹, where n is the no of bits in the magnitude.
Ex: 1000-8 & 10000--16
Characteristics of 2's compliment no.s:
Properties:
Decimal
+7
+6
Signed binary numbers:
+5
+4
+3
+2
+1
+0
-0
1. There is one unique zero
2's comp of 0 is 0
-2
-3
-4
-5
-6
-7
8
2.
3. The leftmost bit can't be used to express a quantity . it is a 0 no. is +ve.
4.
For an n-bit word which includes the sign bit there are (2¹-1-1) +ve integers,
2n-1-ve integers & one 0, for a total of 2" uniquestates.
5. Significant information is containd in the 1's of the +ve no.s & 0's of the ve
no.s
6. A _ve no. may be converted into a +ve no. by finding its 2's comp.
DIGITAL LOGIC DESIGN
Sign 2's comp form
0111
0110
0101
0100
0011
0010
0011
0000
1111
1110
1101
1100
1011
1010
1001
1000
Sign 1's comp form
0111
0110
0101
0100
0011
0010
0011
0000
1111
1110
1101
1100
1011
1010
1001
1000
Sign mag form
0111
0110
0101
0100
0011
0010
0011
0000
1000
1001
1010
1011
1100
1101
1110
1111
Page no.Methods of obtaining 2's comp of a no:
bits
●
Ex:
In 3 ways
1.
By obtaining the 1's comp of the given no. (by changing all 0's to 1's & 1's to 0's) &
then adding 1.
By subtracting the given n bit no N from 2¹
2.
3. tarting at the LSB, copying down each bit upto
encountered, and complimenting the remaining bits.
Ex: Express -45 in 8 bit 2's comp form
I method:
1's comp of 00101101 & the add 1
00101101
11010010
II method:
+45 in 8 bit form is 00101101
III method:
+1
11010011
Subtract the given no. N from 2¹
2⁰ = 100000000
Subtract 45= -00101101
DIGITAL LOGIC DESIGN
Original no: 00101101
First 1 bit 1
Copy up to
Compliment remaining : 1101001
+1
11010011
is 2's comp form
11010011
& including the first 1 bit
is 2's comp
Page no. 10-73.75 in 12 bit 2'compform
I method
01001001.1100
10110110.0011
II method:
28= 100000000.0000
Sub 73.75--01001001.1100
10110110.0100 is 2's
III method:
Orginalno
Copy up to 1'st bit
100
Comp the remaining bits:
+14
-14
+1
10110110.0100 is 2's comp
+46
-14
2's compliment Arithmetic:
The 2's comp system is used to rep -ve no.s using modulus arithmetic. The word length
of a computer is fixed. i.e, if a 4 bit no. is added to another 4 bit no the result will be
only of 4 bits. Carry if any, from the fourth bit will overflow called the Modulus
arithmetic.
: 01001001.1100
= 00101110
=+11110010
10110110.0
Ex:1100+1111=1011
In the 2's compl subtraction, add the 2's comp of the subtrahend to the minuend. If there
is a carry out, ignore it, look at the sign bit I,e, MSB of the sum term .If the MSB is a
0, the result is positive.& it is in true binary form. If the MSB is a` (carry in or no carry
at all) the result is negative.& is in its 2's comp form. Take its 2's comp to find its
magnitude in binary.
Ex: Subtract 14 from 46 using 8 bit 2's comp arithmetic:
= 00001110
= 11110010
DIGITAL LOGIC DESIGN
10110110.0100
2's comp
.
2's comp form of -14
Page no. 11-32
form. So the result is +00100000=+32.
EX: Add -75 to +26 using 8 bit 2's comp arithmetic
+75
-75
+26
-75
-49
(1)00100000
ignore carry
Ignore carry, The MSB is 0. so the result is +ve. & is in normal binary
= 01001011
=10110101
= 00011010
=+10110101
11001111
●
-45.75 +11010010.0100
●
No carry, MSB is a 1, result is _ve & is in 2's comp. The magnitude is 2's comp of
11001111. i.e, 00110001 = 49. so result is -49
Ex: add -45.75 to +87.5 using 12 bit arithmetic
+87.501010111.1000
1's compliment of n number:
-41.75 (1)00101001.1100 ignore carry
MSB is 0, result is +ve. +41.75
2's comp
2's comp form of -75
No carry
+99
-99
It is obtained by simply complimenting each bit of the no,.& also, 1's comp of a
no, is subtracting each bit of the no. form 1.This complemented value rep the
ve of the original no. One of the difficulties of using 1's comp is its rep o f
zero. Both 00000000 & its 1's comp 11111111 rep zero.
The 00000000 called +ve zero& 11111111 called -ve zero.
=
Ex: -99 &-77.25 in 8 bit 1's comp
=
01100011
10011100
+77.25 =
-77.25 =
1's compliment arithmetic:
In 1's comp subtraction, add the 1's comp of the subtrahend to the minuend. If there is a
carryout, bring the carry around & add it to the LSB called the end around carry. Look at the
sign bit (MSB). If this is a 0, the result is +ve & is in true binary. If the MSB is a 1 (carry or no
carry), the result is -ve & is in its is comp form .Take its 1's comp to get the magnitude inn
binary.
DIGITAL LOGIC DESIGN
01001101.0100
10110010.1011
Page no. 12Ex: Subtract 14 from 25 using 8 bit 1's EX: ADD-25 to +14
25
+14
-45
-25
+11
Binary codes
0
Decimal
1
2
3
4
5
6
7
8
9
=
=
00001011
MSB is a 0 so result is +ve (binary)
+1
Reflective Code
=+1110
DIGITAL LOGIC DESIGN
00011001
11110001
BCD
8421
(1)00001010
Binary codes are codes which are represented in binary system with modification from the
original ones.
Weighted Binary codes
Non Weighted Codes
Weighted binary codes are those which obey the positional weighting principles, each
position of the number represents a specific weight. The binary counting sequence is
an example.
Bi-Quinary
5043210
0000
0011
0001
0100
0000 0000 0000 0100001
0111 0001 0001 0100010
0010 0101 0110 0010 0011 0100100
0011 0110 0101 0011 0101 0101000
0100 0111 0100 0100 0111 0110000
0101 1000 1011 1011 1000 1000001
0110 1001 1010 1100 1010 1000010
0111 1010 1001 1101 1100 1000100
1000 1011 1000 1110 1110 1001000
1001 1111 1111 1111 1111 1010000
-11
Excess-3 84-2-1 2421 5211
= 00001110
=+11100110
11110100
No carry MSB =1
result-ve=-1110
5 0 4 3 2 1 0
0
1
2
3
4
5 X
6 X
7 X
8 X
9
X
X
X
X X
X
X
X
X
X
X
A code is said to be reflective when code for 9 is complement for the code for 0, and
Page no. 13
X
Xso is for 8 and 1 codes, 7 and 2, 6 and 3, 5 and 4. Codes 2421, 5211, and excess-3 are
reflective, whereas the 8421 code is not.
Sequential Codes
A code is said to be sequential when two subsequent codes, seen as numbers in binary
representation, differ by one. This greatly aids mathematical manipulation of data. The 8421 and
Excess-3 codes are sequential, whereas the 2421 and 5211 codes are not.
Non weighted codes
Non weighted codes are codes that are not positionally weighted. That is, each
position within the binary number is not assigned a fixed value. Ex: Excess-3 code
Excess-3 Code
Excess-3 is a non weighted code used to express decimal numbers. The code derives
its name from the fact that each binary code is the corresponding 8421 code plus
0011(3).
Gray Code
The gray code belongs to a class of codes called minimum change codes, in
which only one bit in the code changes when moving from one code to the next. The
Gray code is non-weighted code, as the position of bit does not contain any weight.
The gray code is a reflective digital code which has the special property that any two
subsequent numbers codes differ by only one bit. This is also called a unit- distance
code. In digital Gray code has got a special place.
Decimal Binary
Number Code
0
0000
1
0001
2
0010
3
0011
4
0100
5
0101
6
0110
7
0111
DIGITAL LOGIC DESIGN
Gray Code
0000
0001
0011
0010
0110
0111
0101
0100
Decimal
Number
8
9
10
11
12
13
14
15
Binary
Code
1000
1001
1010
1011
1100
1101
1110
1111
Gray Code
1100
1101
1111
1110
1010
1011
1001
1000
Page no. 14Binary to Gray Conversion
8421 BCD code (Natural BCD code):
Gray Code MSB is binary code MSB.
Gray Code MSB-1 is the XOR of binary code MSB and MSB-1.
MSB-2 bit of gray code is XOR of MSB-1 and MSB-2 bit of binary code.
MSB-N bit of gray code is XOR of MSB-N-1 and MSB-N bit of binary code.
Each decimal digit 0 through 9 is coded by a 4 bit binary no. called natural binary codes.
Because of the 8,4,2,1 weights attached to it. It is a weighted code & also sequential . it is useful
for mathematical operations. The advantage of this code is its case of conversion to & from
decimal. It is less efficient than the pure binary, it require more bits.
Ex: 14-1110 in binary
BCD Addition:
The disadvantage of the BCD code is that, arithmetic operations are more complex than
they are in pure binary. There are 6 illegal combinations 1010,101 1,1 100,1101,1110,1111 in
these codes, they are not part of the 8421 BCD code system. The disadvantage of 8421 code is,
the rules of binary addition 8421 no, but only to the individual 4 bit groups.
But as 0001 0100 in 8421 ode.
It is individually adding the corresponding digits of the decimal no,s expressed in
4 bit binary groups starting from the LSD. If there is no carry & the sum term is not an illegal
code, no correction is needed .If there is a carry out of one group to the next group or if the sum
term is an illegal code then 610(0100) is added to the sum term of that group & the resulting carry
is added to the next group.
In BCD
In BCD
Ex: Perform decimal additions in 8421 code
(a)25+13
25
+13
0010 0101
+0001 0011
38
0011 1000
No carry, no illegal code .This is the corrected sum
DIGITAL LOGIC DESIGN
Page no. 15(b). 679.6+536.8
679.6 = 0110
+536.8 = +0101
1216.4
In BCD
In BCD
58.9
BCD Subtraction:
(1)0001
1
+1
0001
206.7
-147.8=
1
1011
+0110
38= 0011
-15 = -0001
.(b) 206.7-147.8
(1)0000
1
-0110 0110.
+1
2
DIGITAL LOGIC DESIGN
0010
+ 0011
1000
0101
23 0010 0011
No borrow, so correct difference.
= 0010 0000 0110
-0001 0100 0111
0000 1011 1110
-0110
0111
0011
1010
0101 1000
(1)0101
1
+1
0001
1
Performed by subtracting the digits of each 4 bit group of the subtrahend the digits from
the corresponding 4- bit group of the minuend in binary starting from the LSD. if there is no
borrow from the next group, then 610(0110)is subtracted from the difference term of this group.
(a)38-15
0111
0110
1001
0010
0110
+0110
1001
.0110 in BCD
.1000 in BCD
1111
subtract 0110
. 1110
+ 0110
. (1)0100
1
+1
0110
illegal codes
add 0110 to each
propagate carry
0100
in BCD
in BCD
borrows are present
Page no. 16BCD Subtraction using 9's & 10's compliment methods:
Form the 9's & 10's compliment of the decimal subtrahend & encode that no. in
the 8421 code. the resulting BCD no.s are then added.
EX: 305.5 168.8
305.5 =
-168.8=
305.510 =
+831.110=
(1)0001
305.5
+83.1
136.7
0011 0000 0101
+1000
0011 0001
(1)136.6
+1011 0011 0110.
+0110
Excess three(xs-3)code:
+1
0001 0011
Excess-3 Addition:
0011
9's comp of -168.8
end around carry
corrected difference
0101
0001
0110
0110 . 0110
0110. 0111
= 136.7
9's comp of 1,
1011 is illegal code
add 0110
+1
68.8 in BCD
End around carry
It is a non-weighted BCD code .Each binary codeword is the corresponding 8421
codeword plus 0011(3).It is a sequential code & therefore, can be used for arithmetic
operations. It is a self-complementing code.s o the subtraction by the method of compliment
addition is more direct in xs-3 code than that in 8421 code. The xs-3 code has six invalid states
0000,00 10,1101,1110,1111.. It has interesting properties when used in addition & subtraction.
Add the xs-3 no.s by adding the 4 bit groups in each column starting from the LSD. If
there is no carry starting from the addition of any of the 4-bit groups, subtract 0011 from the
sum term of those groups (because when 2 decimal digits are added in xs-3 & there is no carry,
result in xs-6). If there is a carry out, add 0011 to the sum term of those groups( because when
there is a carry, the invalid states are skipped and the result is normal binary).
DIGITAL LOGIC DESIGN
Page no. 17EX:
37
+28
65
Excess -3 (XS-3) Subtraction:
Ex: 267-175
0110
+0101
1011
+1
DIGITAL LOGIC DESIGN
1100
-0011
1001
267 0101 1001 1010
-175= -0100 1010 1000
0000 1111 0010
+0011-0011 +0011
0011 1100 +0011
1010
1011
(1)0101 carry generated
0101
+0011
Subtract the xs-3 no.s by subtracting each 4 bit group of the subtrahend from the
corresponding 4 bit group of the minuend starting form the LSD .if there is no borrow from the
next 4-bit group add 0011 to the difference term of such groups (because when decimal digits are
subtracted in xs-3 & there is no borrow, result is normal binary). If there is a borrow, subtract
0011 from the differenceterm(b coz taking a borrow is equivalent to adding six invalid states,
result is in xs-6)
1000
propagate carry
=9210
add 0011 to correct 0101 &
subtract 0011 to correct 1100
=6510
Page no. 18Xs-3 subtraction using 9's & 10's compliment methods:
Subtraction is performed by the 9's compliment or 10's compliment
Ex:687-348 The subtrahend (348) xs -3 code & its compliment are:
+1
687
-348
339
1001
+1001
(1)0011
0011
+0011
9's comp of 348=651
Xs-3 code of 348 = 0110 0111 1011
0110
1's comp of 348 in xs-3 = 1001 1000 0100
Xs=3 code of 348 in xs-3 = 1001 1000 0100
_ (1)0010 (1)0011
+1
687
+651 9's compl of 348
(1)338
DIGITAL LOGIC DESIGN
+1 end around carry
339
1011
1000
0010 1110
0011
+0011
0110
corrected difference in decimal
1010
0100
1110
carry generated
+1
1111
+0011
687 in xs-3
1's comp 348 in xs-3
1100
propagate carry
end around carry
(correct 1111 by sub0011 and
correct both groups of 0011 by
adding 0011)
corrected diff in xs-3 = 33010
Page no. 19The Gray code (reflective -code):
Gray code is a non-weighted code & is not suitable for arithmetic operations. It is not a
BCD code. It is a cyclic code because successive code words in this code differ in one bit
position only i.e, it is a unit distance code.Popular of the unit distance code.It is also a reflective
code i.e,both reflective & unit distance. The n least significant bits for 2n through 2¹+¹-1 are the
mirror images of thosr for 0 through 2"-1.An N bit gray code can be obtained by reflecting an N-
1 bit code about an axis at the end of the code, & putting the MSB of 0 above the axis & the
MSB of 1 below the axis.
Reflection of gray codes:
1 bit
0
1
DIGITAL LOGIC DESIGN
Gray Code
3 bit
2 bit
00
01
11
10
000
001
011
010
110
111
101
110
4 bit
0000
0
0001 1
0011 2
0010
3
0110
4
0111
5
0101
6
0100
7
1100 8
1101
1111 10
1110
11
1010
12
1011 13
1001 14
1000 15
Decimal
4 bit binary
0000
0001
0010
0011
0100
0101
0110
0111
1000
1001
1010
1011
1100
1101
1110
1111
Page no. 20Weighted
Binary
Non-weighted Reflective
Excess-3 Gray
BCD
0
1
2
3
4
5
6
7
8
9
Five-bit
BCD codes
Decimal
2421
DIGITAL LOGIC DESIGN
Codes
8421
Sequential Alphanumeric Error detecting
and correcting
5211 Excess-3
Excess-3
8421 2421 3321 4221 5211 5311 5421 6311 7421 7421 8421
8421 code
0000
0001
0010
0011
0100
0100
0110
0111
1000
1001
Error - Detecting codes: When binary data is transmitted & processed,it is susceptible to noise
that can alter or distort its contents. The 1's may get changed to 0's & 1's because digital
systems must be accurate to the digit, error can pose a problem. Several schemes have been
devised to detect the occurrence of a single bit error in a binary word, so that whenever such an
error occurs the concerned binary word can be corrected & retransmitted.
ASCII EBCDIC Hollerith
Binary codes block diagram
Parity: The simplest techniques for detecting errors is that of adding an extra bit known as parity
bit to each word being transmitted.Two types of parity: Oddparity, evenparity forodd parity, the
parity bit is set to a _0° or a _1' at the transmitter such that the total no. of 1 bit in the word
including the parity bit is an odd no.For even parity, the parity bit is set to a _0' or a _1' at the
transmitter such that the parity bit is an even no.
Parity Hamming
Odd parity
1
0
0
1
0
1
1
0
0
1
Even parity
0
1
1
0
1
0
0
1
1
0
Page no. 21When the digit data is received . a parity checking circuit generates an error signal if the
total no of 1's is even in an odd parity system or odd in an even parity system. This parity check
can always detect a single bit error but cannot detect 2 or more errors with in the same word.Odd
parity is used more often than even parity does not detect the situation. Where all 0's are created
by a short ckt or some other fault condition.
Ex: Even parity scheme
(a) 10101010 (b) 11110110
Ans:
(a) No. of 1's in the word is even is 4 so there is no error
(b) No. of 1's in the word is even is 6 so there is no error
(c) No. of 1's in the word is odd is 5 so there is error
Ex: odd parity
(a)10110111
Checksums:
(c)10111001
Ans:
(a) No. of 1's in the word is even is 6 so word has error
(b) No. of 1's in the word is even is 4 so word has error
No. of 1's in the word is odd is 5 so there is no error
(c)
Block parity:
(b) 10011010
(c)11101010
Simple parity can't detect two errors within the same word. To overcome this, use a sort
of 2 dimensional parity. As each word is transmitted, it is added to the sum of the previously
transmitted words, and the sum retained at the transmitter end. At the end of transmission, the
sum called the check sum. Up to that time sent to the receiver. The receiver can check its sum
with the transmitted sum. If the two sums are the same, then no errors were detected at the
receiver end. If there is an error, the receiving location can ask for retransmission of the entire
data, used in teleprocessing systems.
DIGITAL LOGIC DESIGN
Block of data shown is create the row & column parity bits for the data using odd parity.
The parity bit 0 or 1 is added column wise & row wise such that the total no. of 1's in each
column & row including the data bits & parity bit is odd as
Page no. 22Data
10110
10001
10101
00010
11000
00000
11010
Error Correcting Codes:
‒‒‒‒‒‒‒‒‒
Parity bit
0
1
0
0
1
1
0
A code is said to be an error-correcting code, if the code word can always be deduced
from an erroneous word. For a code to be a single bit error correcting code, the minimum
distance of that code must be three. The minimum distance of that code is the smallest no. of bits
by which any two code words must differ. A code with minimum distance of 3 can't only correct
single bit errors but also detect ( can't correct) two bit errors, The key to error correction is that
it must be possible to detect & locate erroneous that it must be possible to detect & locate
erroneous digits. If the location of an error has been determined. Then by complementing the
erroneous digit, the message can be corrected, error correcting, code is the Hamming code, In
this, to each group of m information or message or data bits, K parity checking bits denoted by
P1,P2,-- ---pk located at positions 2 k-1 from left are added to form an (m+k) bit code word.
DIGITAL LOGIC DESIGN
data
10110
10001
10101
00010
11000
00000
11010
To correct the error, k parity checks are performed on selected digits of each code word, & the
position of the error bit is located by forming an error word, & the error bit is then
complemented. The k bit error word is generated by putting a 0 or a 1 in the 2 k-¹th position
depending upon whether the check for parity involving the parity bit Pk is satisfied or not.Error
positions & their corresponding values:
Page no. 23Error Position
0
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
The word format
0
1
2
3
4
5
Decimal Digit
7
8
9
For 15 bit code
C4 C3 C2 C1
0000
0001
0010
0011
0100
0101
0 1 10
011 1
100 0
100 1
10 1 0
101
1
1 1 0 0
1
1 0
1
1
1 1
0
1 1 1
7-bit Hamming code:
To transmit four data bits, 3 parity bits located at positions 20 21&2² from left are
added to make a 7 bit codeword which is then transmitted.
DIGITAL LOGIC DESIGN
P₁ P2 D3
D Data bits P-
Parity bits
For BCD
P4
P1P2D3P4D5D6D7
For 12 bit code
C4 C3 C2 C1
0000
0001
0010
0011
0100
0101
0 1
01
1
100
0
10 0 1
101 0
10 1 1
1 1 0 0
000 000 0
110 100 1
0 10 101 1
100 0011
100 1 1 0 0
0 1 0010
1
1 10 0 1 1
000 1
1 1 1
0
00
0 1 10 0
0
1
0
1
10
1
D5
D6 D7
For 7 bit code
C3 C₂ C₁
000
001
010
011
100
101
1 10
1 1 1
1
For Excess-3
P1P2D3P4D5D6D7
1 0 0 0 0 1
1
1 00 1 10
0
1
0 1 0010
1 10 0 1 1 0
000 1 1 1 1
0000
1 1 1
0
0 1
1 01
0 1 1
0 1 1
10 01
1
0 1 0
0
0 1 1
100
Page no. 24Ex: Encode the data bits 1101 into the 7 bit even parity Hamming Code
The bit pattern is
P1P2D3P4D5D6D7
1
Bits 1,3,5,7 (P₁ 111) must have even parity, so P₁=1
Bits 2, 3, 6, 7(P₂ 101) must have even parity, so P2=0
Bits 4,5,6,7 (P4 101)must have even parity, so P4=0
The final code is 1010101
101
EX: Code word is 1001001
Bits 1,3,5,7 (C₁ 1001) →no error →put a 0 in the 1's position-C1=0
Bits 2, 3, 6, 7(C₂ 0001)) → error →put a 1 in the 2's position-C2=1
Bits 4,5,6,7 (C4 1001)) →no error →put a 0 in the 4's position-C3=0
15-bit Hamming Code: It transmit 11 data bits, 4 parity bits located 20 2¹ 2² 2³
Word format is
P₁ P₂ D3 P4 D5 D6 D7 P8 D9 D10 D11 D12 D13 D14 D15
Alphanumeric Codes:
12-Bit Hamming Code: It transmit 8 data bits, 4 parity bits located at position 20 2¹ 2² 2³
Word format is
P₁ P₂ D3 P4 D5 D6
DIGITAL LOGIC DESIGN
D7 P8 D9 D10 D11 D12
These codes are used to encode the characteristics of alphabet in addition to the decimal
digits. It is used for transmitting data between computers & its I/O device such as printers,
keyboards & video display terminals.Popular modern alphanumeric codes are ASCII code &
EBCDIC code.
Page no. 25Digital Logic Gates
Boolean functions are expressed in terms of AND, OR, and NOT operations, it is easier to
implement a Boolean function with these type of gates.
Name
AND
OR
Inverter
Buffer
NAND
NOR
Exclusive-OR
(XOR)
Exclusive-NOR
or
equivalence
DIGITAL LOGIC DESIGN
X
y
x
y
X
X
y
X
Graphic
symbol
D
F
F
Algebraic
function
F
F-x-y
F-x+y
F-x'
F-x
-F F- (x + y)'
F-(xy)'
F-xy' + x'y
-x@y
F- xy + x'y'
- (x + y)'
Truth
table
X
0
0
0 1
1 0
1
1
X
y
0
0
0
0 1 1
1
0
1 1
1
1
X
0
0
1
1
y
0
0
0 1
0
1
X
0
0
1
1
0
1
X
X F
y
0 0
1 1
y
0
1
y
F
0
0
0 1
1
1
401
0
1
0
0
0
1
F
0
1
y
0
1
0
1 0
1
1
1
1
1
0
1
0
0
0
0
1
1
1
0
0
1
Page no. 26Properties of XOR Gates
●
●
XOR (also ) : the "not-equal" function
XOR(X,Y)= X Y = X'Y + XY'
Identities:
X
Y
Properties:
Universal Logic Gates
NAND and NOR gates are called Universal gates. All fundamental gates (NOT, AND, OR) can be
realized by using either only NAND or only NOR gate. A universal gate provides flexibility and
offers enormous advantage to logic designers.
NOT Gate
X
NAND as a Universal Gate
NAND Known as a "universal" gate because ANY digital circuit can be implemented with NAND
gates alone.
To prove the above, it suffices to show that AND, OR, and NOT can be implemented using
NAND gates only.
AND Gate
X + 0 = X
X
1=X'
X X=0
XX' = 1
ΧΘΥ=ΥΘΥ
(XY) W = X(YOW)
Da
OR Gate
Da
Da
F = (X.X)'
=X+X
=X'
Da
DIGITAL LOGIC DESIGN
F = ((X+Y)')'
= (X+Y')'
=X^.y"
=X.Y
F = (X'•Y')'
=X"+Y"
=X+Y
X
X
Y
X
F=X
Do
FX.Y
De
F=X+Y
Page no. 27Boolean Algebra: In 1854, George Boole developed an algebraic system now called Boolean algebra. In
1938, Claude E. Shannon introduced a two-valued Boolean algebra called switching algebra that
represented the properties of bistable electrical switching circuits. For the formal definition of Boolean
algebra, we shall employ the postulates formulated by E. V. Huntington in 1904.
Boolean algebra is a system of mathematical logic. It is an algebraic system consisting of the set of
elements (0, 1), two binary operators called OR, AND, and one unary operator NOT. It is the basic
mathematical tool in the analysis and synthesis of switching circuits. It is a way to express logic functions
algebraically.
Boolean algebra, like any other deductive mathematical system, may be defined with aset of elements, a
set of operators, and a number of unproved axioms or postulates. A set of elements is anycollection of
objects having a common property. If S is a set and x and y are certain objects, then x Î Sdenotes that x is
a member of the set S, and y ÏS denotes that y is not an element of S. A set with adenumerable number of
elements is specified by braces: A = {1,2,3,4}, i.e. the elements of set A are thenumbers 1, 2, 3, and 4. A
binary operator defined on a set S of elements is a rule that assigns to each pair ofelements from S a
unique element from S. Example: In a*b=c, we say that * is a binary operator if it specifies a rule for
finding c from the pair (a,b)and also if a, b, c ÎS.
Axioms and laws of Boolean algebra
Axioms or Postulates of Boolean algebra are a set of logical expressions that we accept without proof and
upon which we can build a set of useful theorems.
AND Operation
Axiom1 : 0.0=0
Axiom2: 0.1=0
Axiom3: 1.0=0
Axiom4: 1.1=1
AND Law
Law1: A.0=0 (Null law)
Law2: A.1-A (Identity law)
Law3: A.A=A (Impotence law)
OR Operation
0+0=0
0+1=1
1+0=1
1+1=1
NOT Operation
0=1
T=0
OR Law
Law1: A+0=A
Law2: A+1=1
Law3: A+A=A (Impotence law)
CLOSURE: The Boolean system is closed with respect to a binary operator if for every pair of
Boolean values,it produces a Boolean result. For example, logical AND is closed in the Boolean
system because it accepts only Boolean operands and produces only Boolean results.
_ A set S is closed with respect to a binary operator if, for every pair of elements of S, the binary
operator specifies a rule for obtaining a unique element of S.
For example, the set of natural numbers N = {1, 2, 3, 4,
binary operator plus (+) by the rule of arithmetic addition,
unique c ÎN by the operation a + b = c.
DIGITAL LOGIC DESIGN
9} is closed with respect to the
since for any a, b Î N we obtain a
Page no. 28ASSOCIATIVE LAW:
A binary operator * on a set S is said to be associative whenever (x * y) * z= x * (y * z) for all x, y, z Î S,
forall Boolean values x, y and z.
COMMUTATIVE LAW:
A binary operator * on a set S is said to be commutative whenever x * y = y* x for all x, y, z e S
IDENTITY ELEMENT:
A set S is said to have an identity element with respect to a binary operation * on S if there exists an element
e e S with the property e * x= x * e = x for every x € S
BASIC IDENTITIES OF BOOLEAN ALGEBRA
Postulate 1 (Definition): A Boolean algebra is a closed algebraic system containing a set K of two or more
elements and the two operators and + which refer to logical AND and logical OR •x + 0 = x
x 0 = 0
x + 1 = 1
x 1 = 1
●
●
●
●
X + X = X
X X = X
x + x' = X
x x' = 0
x + y = y + x
xy = yx
x + (y+z) = (x + y) + z
x (yz) = (xy) z
x (y + z) = xy + xz
x + yz = (x + y )(x + z)
(x + y)' = x'y'
(xy)' = x' + y'
DIGITAL LOGIC DESIGN
Page no. 29(x')' = x
DeMorgan's Theorem
(a) (a + b)' = a'b'
(b) (ab)' = a' + b'
Generalized DeMorgan's Theorem
(a) (a + b + ... z)' = a'b' ... z'
(b) (a.b... z)' = a' + b' + Z
Basic Theorems and Properties of Boolean algebra Commutative law
Lawl: A+B=B+A
Associative law
Lawl: A+ (B+C) = (A +B) +C
Distributive law
Lawl: A.(B+C) = AB+ AC
Absorption law
Lawl:
A +AB=A
Solution: A(1+B)
A
AB+A'C+BC=AB+A'C+(A+A') BC
=AB+A'C+ABC+A'BC
Law2: A.B=B.A
DIGITAL LOGIC DESIGN
Law2: A(B.C) = (A.B)C
Law2: A + BC = (A + B).(A +C)
Law2:
Solution:
Consensus Theorem
Theorem1. AB+ A'C + BC = AB + A'C Theorem2. (A+B). (A’+C).(B+C) =(A+B).( A³+C)
The BC term is called the consensus term and is redundant. The consensus term is formed from a
PAIR OF TERMS in which a variable (A) and its complement (A') are present; the consensus
term is formed by multiplying the two terms and leaving out the selected variable and its
complement
Consensus Theorem1 Proof:
A(A +B) = A
A.A+A.B
A+A.B
A(1+B)
A
Page no. 30=AB(1+C) +A'C(1+B)
= AB+ A'C
Principle of Duality
Each postulate consists of two expressions statement one expression is transformed into the
other by interchanging the operations (+) and (.) as well as the identity elements 0 and 1.
Such expressions are known as duals of each other.
If some equivalence is proved, then its dual is also immediately true.
If we prove: (x.x)+(x'+x')=1, then we have by duality: (x+x).(x'.x')=0
The Huntington postulates were listed in pairs and designated by part (a) and part (b) in below
table.
Table for Postulates and Theorems of Boolean algebra
Part-A
Part-B
A+0=A
A+1=1
A+A=A (Impotence law)
A+ A1
AA (double inversion law)
Commutative law: A+B=B+A
Associative law: A + (B+C) = (A +B) +C
Distributive law:
A.(B+C) = AB+ AC
Absorption law: A +AB=A
DeMorgan Theorem:
(A+B) = A. B
Redundant Literal Rule: A+ AB=A+B
Consensus Theorem: AB+ A'C + BC = AB + A'C
F(vars) = expression
↓
L
Set of binary Variables
A.0=0
A.1=A
A.A=A (Impotence law)
A. AO
Consider an example for the Boolean function
F1 = x + y'z
DIGITAL LOGIC DESIGN
A.B=B.A
A(B.C) = (A.B)C
A + BC = (A + B).(A +C)
A(A + B) = A
(A.B) = =
Boolean Function
Boolean algebra is an algebra that deals with binary variables and logic operations.
A Boolean function described by an algebraic expression consists of binary variables, the
constants 0 and 1, and the logic operation symbols.
For a given value of the binary variables, the function can be equal to either 1 or 0.
A + B
A. (A+B)=AB
(A+B). (A'+C).(B+C) =(A+B).( A'+C)
Operators (+, •, ')
Constants (0, 1)
Groupings (parenthesis)
Variables
Page no. 31The function F1 is equal to 1 if x is equal to 1 or if both y' and z are equal to 1. F1 is equal to 0
otherwise. The complement operation dictates that when y' = 1, y = 0. Therefore, F1 = 1 if x = 1
or if y = 0 and z = 1.
A Boolean function expresses the logical relationship between binary variables and is evaluated
by determining the binary value of the expression for all possible values of the variables.
A Boolean function can be represented in a truth table. The number of rows in the truth
table is 2n, wh n is the number of variables in the function. The binary combinations for the
truth table are obtained from the binary numbers by counting from 0 through 2n - 1.
Truth Table for F1
xyz F₁
0 0 0 0
0011
0100
0 1 0 0
0 1 1 0
1001
101 1
1 0 1
1 1 1
1
1
Truth Tables
Note:
Q: Let a function F() depend on n variables. How many rows are there in the truth table of F() ?
A: 2 rows, since there are 2" possible binary patterns/combinations for the n variables.
X
●
●
y z F₁
Z
0
0
1
0
0
0 0
O
Enumerates all possible combinations of variable values and the corresponding function
value
Truth tables for some arbitrary functions
F1(x,y,z),F2(x,y,z), and F3(x,y,z) are shown to the below.
DIGITAL LOGIC DESIGN
F₂
1
0
X
F3
1
D-
Gate Implementation of F1 = x + y'z
1
Page no. 32
- F₁O
1
0
1
0
100
0
101 0
1 0 0
1 1
1
0
1
1
●
●
●
●
O
●
●
1
●
0
Truth tables can be used to prove equality theorems.
However, the size of a truth table grows exponentially with the number of variables
involved, hence unwieldy. This motivates the use of Boolean Algebra.
Boolean expressions-NOT unique
Unlike truth tables, expressions epresenting
a Boolean function are NOT unique.
Example:
1
1
1
0
1
1
0
0
0
1
Truth table: a unique representation of a Boolean function
If two functions have identical truth tables, the functions are equivalent (and vice-
versa).
DIGITAL LOGIC DESIGN
F(x,y,z) = x' y' z' + x'•y•z' +
x•y•z’
G(x,y,z) = x' y' z' + y•z'
The corresponding truth tables for
F() and G() are to the right. They are
identical.
Thus, F() = G()
X
0
0
0 0
1
1
y
1
O
0 1
1
1
Algebraic Manipulation (Minimization of Boolean function)
O
N
1
O
O
0 0
1
1 00
1
0 0
1 0 0
1 0 1 1
0
1
G
1
1 1
0 0
O
Boolean algebra is a useful tool for simplifying digital circuits.
Why do it? Simpler can mean cheaper, smaller, faster.
Example: Simplify F = x'yz + x'yz' +xz.
-
F= x'yz + x'yz' + xz
= x'y(z+z') + xz
= xy• 1 + xz
Page no. 33= x'y + xz
Example: Prove
x'y'z' + x'yz' + xyz' = x'z' + yz'
Proof:
x'y'z'+ x'yz'+ xyz'
Complement of a Function
The complement of a function is derived by interchanging (• and +), and (1 and 0), and
complementing each variable.
●
Otherwise, interchange 1s to Os in the truth table column showing F.
The complement of a function IS NOT THE SAME as the dual of a function.
Example
= x'y'z' + x'yz' + x'yz' + xyz'
= x'z'(y'+y)+ yz'(x'+x)
= x'z' 1 + yz' 1
= x'z' + yz'
Find G(x,y,z), the complement of F(x,y,z) = xy'z' + x'yz
Ans: G = F' = (xy'z' + x'yz)'
= (xy'z')' • (x'yz)'
DeMorgan
= (x'+y+z) (x+y'+z') DeMorgan again
Note: The complement of a function can also be derived by finding the function's dual, and
then complementing all of the literals
Canonical and Standard Forms
Definitions
We need to consider formal techniques for the simplification of Boolean functions.
Identical functions will have exactly the same canonical form.
Minterms and Maxterms
● Sum-of-Minterms and Product-of- Maxterms
●
Product and Sum terms
Sum-of-Products (SOP) and Product-of-Sums (POS)
DIGITAL LOGIC DESIGN
Literal: A variable or its complement
Product term: literals connected by .
Sum term: literals connected by +
Minterm: a product term in which all the variables appear exactly once, either complemented or
uncomplemented.
Page no. 34Maxterm: a sum term in which all the variables appear exactly once, either complemented or
uncomplemented.
Canonical form: Boolean functions expressed as a sum of Minterms or product of Maxterms are said to be
in canonical form.
Minterm
●
●
Example: Assume 3 variables (A, B, C), and j=3. Then, bj = 011 and its corresponding minterm is denoted
by m; = A'BC
Maxterm
●
●
Represents exactly one combination in the truth table.
Denoted by mj, where j is the decimal equivalent of the minterm's corresponding binary
combination (bj).
A variable in m; is complemented if its value in bj is 0, otherwise is uncomplemented.
●
Represents exactly one combination in the truth table.
Denoted by M₁, where j is the decimal equivalent of the maxterm's corresponding binary
combination (bj).
A variable in M; is complemented if its value in bj is 1, otherwise is uncomplemented.
Example: Assume 3 variables (A, B, C), and j=3. Then, b;= 011 and its corresponding maxterm is denoted
by M;=A+B'+C'
Truth Table notation for Minterms and Maxterms
●
Minterms and Maxterms are easy to denote using a truth table.
Example: Assume 3 variables x,y,z (order is fixed)
Canonical Forms
DIGITAL LOGIC DESIGN
X yz
ooo
Minterm
x'y'z' = mo
0 0 1
x'y'z = m₁
010
x'yz' = m₂
011
x'yz = m3
100 xy'z' = m4
101
xy'z = m5
1
1
0
xyz' = m6
1 1 1
xyz = m7
Maxterm
x+y+z = - Mo
x+y+z' = M₁
x+y' +z = M₂
x+y'+z'= M3
x'+y+z = M4
x'+y+z' = M5
x'+y' +z = M6
x'+y'+z' = M7
Page no. 35●
Every function F() has two canonical forms:
Canonical Sum-Of-Products (sum of minterms)
Canonical Product-Of-Sums (product of maxterms)
Canonical Sum-Of-Products:
The minterms included are those m; such that F( ) = 1 in row j of the truth table for F( ).
Canonical Product-Of-Sums:
The maxterms included are those M; such that F( ) = 0 in row j of the truth table for F().
Example
Consider a Truth table for f₁(a,b,c) at right
The canonical sum-of-products form for f₁ is
f₁(a,b,c) = m₁ + m₂ + M4 + M6
= a'b'c + a'bc' + ab'c' + abc'
●
The canonical product-of-sums form for f₁ is
f₁(a,b,c) = Mo M3 M5 • M7
●
= (a+b+c) (a+b'+c')• (a'+b+c')•(a'+b'+c').
Observe that: m; = M;'
DIGITAL LOGIC DESIGN
b
f₁
0 0 0 0
a
001 1
0 1 0 1
0110
0 0 1
1
10 1 0
1 0 1
1 1 0
1
1
Page no. 36Shorthand: Σ and T
f₁(a,b,c) = m(1,2,4,6), where indicates that this is a sum-of-products form, and m(1,2,4,6)
indicates that the minterms to be included are m₁, m2, m4, and m6.
f₁(a,b,c) = M(0,3,5,7), where indicates that this is a product-of-sums form, and M(0,3,5,7)
indicates that the maxterms to be included are Mo, M3, M5, and M7.
Since mj = M;' for anyj,
[ m(1,2,4,6)= || M(0,3,5,7) = f₁(a,b,c)
●
●
Conversion between Canonical Forms
Replace with T (or vice versa) and replace those j's that appeared in the original form with those
that do not.
●
●
Standard Forms
Example:
f₁(a,b,c)= a'b'c + a'bc' + ab'c' + abc'
= M₁ + m₂ + M4 + M6
= {(1,2,4,6)
= TT(0,3,5,7)
= (a+b+c) (a+b'+c')•(a'+b+c')•(a'+b'+c')
Another way to express Boolean functions is in standard form. In this configuration, the terms that form
the function may contain one, two, or any number of literals.
There are two types of standard forms: the sum of products and products of sums.
The sum of products is a Boolean expression containing AND terms, called product terms, with one or
more literals each. The sum denotes the ORing of these terms. An example of a function expressed as a
sum of products is
F1 = y + xy + x'yz'
The expression has three product terms, with one, two, and three literals. Their sum is, in effect, an OR
operation.
A product of sums is a Boolean expression containing OR terms, called sum terms. Each term may have any
number of literals. The product denotes the ANDing of these terms. An example of a function expressed as
a product of sums is
F2 = x(y' + 2)(x' + y + z')
This expression has three sum terms, with one, two, and three literals. The product is an AND operation.
DIGITAL LOGIC DESIGN
Page no. 37Conversion of SOP from standard to canonical form
Example-1.
Express the Boolean function F = A + B'C as a sum of minterms.
Solution: The function has three variables: A, B, and C. The first term A is missing two variables; therefore,
A = A(B + B') = AB + AB'
This function is still missing one variable, so
A = AB(C + C') + AB' (C + C')
= ABC + ABC' + AB'C + AB'C'
The second term B'C is missing one variable; hence,
B'C = B'C(A + A') = AB'C + A'B'C
Combining all terms, we have
F = A + B'C
=
= ABC + ABC' + AB'C + AB'C' + A'B'C
But AB'C appears twice, and according to theorem (x + x = x), it is possible to remove one of those
occurrences. Rearranging the minterms in ascending order, we finally obtain
F = A'B'C + AB'C + AB'C + ABC' + ABC
= m1 + m4 + m5 + m6 + m7
When a Boolean function is in its sum-of-minterms form, it is sometimes convenient to express the
function in the following brief notation:
F(A, B, C) = [m (1, 4, 5, 6, 7)
Example-2.
Express the Boolean function F = xy + x'z as a product of maxterms.
Solution: First, convert the function into OR terms by using the distributive law:
F = xy + x'z = (xy + x')(xy+z)
= (x + x')(y + x')(x + 2)(y+z)
(x'+y)(x + 2)(y + z)
=
The function has three variables: x, y, and z. Each OR term is missing one variable; therefore,
x'+ y = x' + y + zz' = (x' + y + z)(x' + y + z')
x + z = x +z+yy' = (x + y + z)(x + y' + z)
y + z = y +z+xx' = (x + y + z)(x' + y + z)
Combining all the terms and removing those which appear more than once, we finally obtain
F = (x+y+z)(x + y' + 2)(x' + y + 2)(x' +y+z)
F= MOM2M4M5
A convenient way to express this function is as
follows: F(x, y, z) = лM(0, 2, 4, 5)
The product symbol, π, denotes the ANDing of maxterms; the numbers are the indices of the maxterms of
the function.
DIGITAL LOGIC DESIGN
Page no. 38Two-variable k-map:
A two-variable k-map can have 2²=4 possible combinations of the input variables A and
B Each of these combinations,
B,A ,AB(in the SOP form) is called a minterm.
The minterm may be represented in terms of their decimal designations mo for
ml for
B,m2 for A and m3 for AB, assuming that A represents the MSB. The letter m stands for
minterm and the subscript represents the decimal designation of the minterm. The presence or
absence of a minterm in the expression indicates that the output of the logic circuit assumes logic
1 or logic 0 level for that combination of input variables.
Using Truth Table:
Minimization Techniques
The expression f=‚+ B+A +AB, it can be expressed using min
term as F= m0+m2+m3=Σm(0,2,3)
DIGITAL LOGIC DESIGN
Unit-II
9
0
1
2
3
Minterm Inputs
A
0
0
1
1
A
B
0
1
0
1
Output
F
1
0
1
1
A 1 in the output contains that particular minterm in its sum and a 0 in that column indicates that
the particular mintermdoes not appear in the expression for output . this information can also be
indicated by a two-variable k-map.
Mapping of SOP Expresions:
A two-variable k-map has 22=4 squares .These squares are called cells. Each square on the k-
map represents a unique minterm. The minterm designation of the squares are placed in any
square, indicates that the corresponding minterm does output expressions. And a 0 or no entry in
any square indicates that the corresponding minterm does not appear in the expression for output.
BO 1
A'B' A'B
1 AB AB
9
The minterms of a two-variable k-map
Page no. 39The mapping of the expressions =[m(0,2,3)is
B 0
1
EX: Map the expressions f= B+A
F= m₁+m2-Em(1,2)The k-map is
A
0
1
DIGITAL LOGIC DESIGN
B
1
1
k-map of Em(0,2,3)
0
1
2
1
0
2
)=
1
1
1
0
1
3
1
Minimizations of SOP expressions:
To minimize Boolean expressions given in the SOP form by using the k-map, look for
adjacent adjacent squares having 1's minterms adjacent to each other, and combine them to form
larger squares to eliminate some variables. Two squares are said to be adjacent to each other, if
their minterms differ in only one variable. (i.e, B & A differ only in one variable. so they may
be combined to form a 2-square to eliminate the variable B.similarly all other.
3
The necessary condition for adjacency of minterms is that their decimal designations must
differ by a power of 2. A minterm can be combined with any number of minterms adjacent to it
to form larger squares. Two minterms which are adjacent to each other can be combined to form
a bigger square called a 2-square or a pair. This eliminates one variable - the variable that is not
common to both the minterms. For EX:
m0 and m1 can be combined to yield,
f₁ = m0+m1=+B= (B+
)= m0 and m2 can be combined to yield,
f2 = m0+m2= + =
(+
m1 and m3 can be combined to yield,
Page no. 40m2 and m3 can be combined to yield,
f4 m2+m3=A +AB=A(B+ )=A
mo ,m₁ ,m2 and m3 can be combined to yield,
B
1
0
0
2
f3= m1+m3= B+AB=B( + )=B
fl=
= (B+ ) +A(B+ )
= +A
=1
+ +A +AB
B
f2=
DIGITAL LOGIC DESIGN
0
1
3
B
1
f3=B
1
1
1
1
1
B
3
1
It requires two gate inputs for realization as
f=+B (k-map in SOP form, and logic diagram.)
f4=A
0
0
1
B
3
f5=1
The possible minterm groupings in a two-variable k-map.
Two 2-squares adjacent to each other can be combined to form a 4-square. A 4-square
eliminates 2 variables. A 4-square is called a quad. To read the squares on the map after
minimization, consider only those variables which remain constant through the square, and
ignore the variables which are varying. Write the non complemented variable if the variable is
remaining constant as a 1, and the complemented variable if the variable is remaining constant as
a 0, and write the variables as a product term. In the above figure f₁ read as, because, along the
square, A remains constant as a 0, that is, as, where as B is changing from 0 to 1.
EX: Reduce the minterm f= +A +AB using mapping Expressed in terms of minterms, the
given expression is F=mo+m₁+m2+ m3=mΣ(0,1,3)& the figure shows the k-map for f and its
reduction. In one 2-square, A is constant as a 0 but B varies from a 0 to a 1, and in the other 2-
square, B is constant as a 1 but A varies from a 0 to a 1. So, the reduced expressions is +B.
B
1
f
0
2
1
1
3
Page no. 41The main criterion in the design of a digital circuit is that its cost should be as low as
possible. For that the expression used to realize that circuit must be minimal.Since the cost is
proportional to number of gate inputs in the circuit in the circuit, an expression is considered
minimal only if it corresponds to the least possible number of gate inputs. & there is no
guarantee for that k-map in SOP is the real minimal. To obtain real minimal expression, obtain
the minimal expression both in SOP & POS form form by using k-maps and take the minimal of
these two minimals.
The 1's on the k-map indicate the presence of minterms in the output expressions, where
as the Os indicate the absence of minterms .Since the absence of a minterm in the SOP expression
means the presense of the corresponding maxterm in the POS expression of the same when a
SOP expression is plotted on the k-map, Os or no entries on the k-map represent the maxterms.
To obtain the minimal expression in the POS form, consider the Os on the k-map and follow the
procedure used for combining 1s. Also, since the absence of a maxterm in the POS expression
means the presence of the corresponding minterm in the SOP expression of the same, when a
POS expression is plotted on the k-map, 1s or no entries on the k-map represent the minterms.
Mapping of POS expressions:
Each sum term in the standard POS expression is called a maxterm. A function in two
variables (A, B) has four possible maxterms, A+B,A+, +B, +
They are represented as Mo, M₁, M2, and M3respectively. The uppercase letter M stands for
maxterm and its subscript denotes the decimal designation of that maxterm obtained by treating
the non-complemented variable as a 0 and the complemented variable as a 1 and putting them
side by side for reading the decimal equivalent of the binary number so formed.
For mapping a POS expression on to the k-map, Os are placed in the squares
corresponding to the maxterms which are presented in the expression an dls are placed in the
squares corresponding to the maxterm which are not present in the expression. The decimal
designation of the squares of the squares for maxterms is the same as that for the minterms. A
two-variable k-map & the associated maxterms are asthe maxterms of a two-variable k-map
The possible maxterm groupings in a two-variable k-map
1
1
20000
3
1
1
f₂ = B
B
1 1
f₁ = A
DIGITAL LOGIC DESIGN
3
A
B
1
1 1
1
1
1 1
f₁ = A
1
1
fs=0
Page no. 42Minimization of POS Expressions:
To obtain the minimal expression in POS form, map the given POS expression on to the
K-map and combine the adjacent Os into as large squares as possible. Read the squares putting
the complemented variable if its value remains constant as a 1 and the non-complemented
variable if its value remains constant as a 0 along the entire square (ignoring the variables which
do not remain constant throughout the square) and then write them as a sum term.
Various maxterm combinations and the corresponding reduced expressions are shown in
figure. In this f₁ read as A because A remains constant as a 0 throughout the square and B
changes from a 0 to a 1. f2 is read as B' because B remains constant along the square as a 1 and
A changes from a 0 to a 1. f5
Is read as a 0 because both the variables are changing along the square.
Ex: Reduce the expression f=(A+B)(A+B‘)(A¹+Bʻ) using mapping.
The given expression in terms of maxterms is f=M(0,1,3). It requires two gates inputs
for realization of the reduced expression as
F=AB'
1
0 1
0
0
DIGITAL LOGIC DESIGN
2
AD¹
K-map in POS form and logic diagram
In this given expression ,the maxterm M₂ is absent. This is indicated by a 1 on the k-map. The
corresponding SOP expression is Σm2 or AB'. This realization is the same as that for the POS
form.
Three-variable K-map:
A function in three variables (A, B, C) expressed in the standard SOP form can have eight
possible combinations: A B C, AB C,A BC ,A BC,AB C ,AB C,ABC, and ABC. Each one of these
combinations designate d by m0,m1,m2,m3,m4,m5,m6, and m7, respectively, is called a
minterm. A is the MSB of the minterm designator and C is the LSB.
In the standard POS form, the eight possible combinations are: A+B+C, A+B+C,
A+B +C,A+B + C ‚A + B+ C‚A + B + C ‚A + B + C,A + B + C . Each oneof these combinations
designated by Mo, M1, M2, M3, M4, M5, M6, and M7respectively is called a maxterm. A is the
MSB of the maxterm designator and C is the LSB.
A three-variable k-map has, therefore, 8(=2³) squares or cells, and each square on the
map represents a minterm or maxterm as shown in figure. The small number on the top right
corner of each cell indicates the minterm or maxterm designation.
Page no. 43BC
01 11 10
A
0 ABC ABC ABC ABC
1 ABC ABC ABC ABC
(a) Minterms
00
Ex: Map the expression f=:
C+
+
BC
DIGITAL LOGIC DESIGN
BC
00
The three-variable k-map.
The binary numbers along the top of the map indicate the condition of B and C for each
column. The binary number along the left side of the map against each row indicates the
condition of A for that row. For example, the binary number 01 on top of the second column in
fig indicates that the variable B appears in complemented form and the variable C in non-
complemented form in all the minterms in that column. The binary number 0 on the left of the
first row indicates that the variable A appears in complemented form in all the minterms in that
row, the binary numbers along the top of the k-map are not in normal binary order. They are,
infact, in the Gray code. This is to ensure that twophysically adjacent squares are really adjacent,
i.e., their minterms or maxterms differ by only one variable.
+
0
0A+B+CA+B+C A+B+CA+B+C
In the given expression, the minterms are :
=010-m2:
7
1 A+B+CA+B+C A+B+CA+B+C
+ABC
T
01
00 01 11 10
A
1
3
0 0 1
0 1
8888
5
7
1 0 1 1 1
K-map in SOP form
11
S
=110=m6;ABC=111=m7.
So the expression is f=Σm(1,5,2,6,7)= Σm(1,2,5,6,7). The corresponding k-map is
2
6
10
(b) Maxterms
C=001=m₁ ; =101=m5;
Ex: Map the expression f= (A+B+C),( + + ) ( + + )(A ++)( + +)
In
the
given
expression
the
:A+B+C=000-Mo; ++ =101=M5; + + = 111=M7; A + +=011=M3; + +
=110=M6.
So the expression is f= M (0,5,7,3,6)= π M (0,3,5,6,7). The mapping of the expression is
maxterms
are
Page no. 440
1
BC
DIGITAL LOGIC DESIGN
00
0
1
4
01
1
0
5
11
0
0
3
7
10
1
0
2
K-map in POS form.
Minimization of SOP and POS expressions:
For reducing the Boolean expressions in SOP (POS) form plotted on the k-map, look
at the 1s (Os) present on the map. These represent the minterms (maxterms). Look for the
minterms (maxterms) adjacent to each other, in order to combine them into larger squares.
Combining of adjacent squares in a k-map containing 1s (or Os) for the purpose of simplification
of a SOP (or POS)expression is called looping. Some of the minterms (maxterms) may have
many adjacencies. Always start with the minterms (maxterm) with the least number of
adjacencies and try to form as large as large a square as possible. The larger must form a
geometric square or rectangle. They can be formed even by wrapping around, but cannot be
formed by using diagonal configurations. Next consider the minterm (maxterm) with next to the
least number of adjacencies and form as large a square as possible. Continue this till all the
minterms (maxterms) are taken care of. A minterm (maxterm) can be part of any number of
squares if it is helpful in reduction. Read the minimal expression from the k-map, corresponding
to the squares formed. There can be more than one minimal expression.
Two squares are said to be adjacent to each other (since the binary designations along
the top of the map and those along the left side of the map are in Gray code), if they are
physically adjacent to each other, or can be made adjacent to each other by wrapping around.
For squares to be combinable into bigger squares it is essential but not sufficient that their
minterm designations must differ by a power of two.
General procedure to simplify the Boolean expressions:
1. Plot the k-map and place 1s(0s) corresponding to the minterms (maxterms) of the SOP
(POS) expression.
2. Check the k-map for 1s(Os) which are not adjacent to any other 1(0). They are isolated
minterms(maxterms). They are to be read as they are because they cannot be combined
even into a 2-square.
3.
Check for those 1s(OS) which are adjacent to only one other 1(0) and make them pairs (2
squares).
4. Check for quads (4 squares) and octets (8 squares) of adjacent 1s (Os) even if they contain
some 1s(Os) which have already been combined. They must geometrically form a square
or a rectangle.
5. Check for any 1s(Os) that have not been combined yet and combine them into bigger
squares if possible.
6. Form the minimal expression by summing (multiplying) the product the product (sum)
terms of all the groups.
Reading the K-maps:
Page no. 45While reading the reduced k-map in SOP (POS) form, the variable which remains
constant as 0 along the square is written as the complemented (non-complemented) variable and
the one which remains constant as 1 along the square is written as non-complemented
(complemented) variable and the term as a product (sum) term. All the product (sum) terms are
added (multiplied).
Some possible combinations of minterms and the corresponding minimal expressions
readfrom the k-maps are shown in fig: Here fo is read as 1, because along the 8-square no
variable remains constant. F5 is read as , because, along the 4-square formed by0,m₁m2 and
m3, the variables B and C are changing, and A remains constant as a 0. Algebraically,
9
f5= mo+m₁+m2+m3
BC
0
-
BC
0
1
00 01
0
..
4
00
1
0
5
11 10
3
f₁ = BC + AB + AC
01 11
1
7
1₂=B+C
3
7
1
10
2
6
2
6
=
=
+
+ C+
(+C)+ B(C+)
BC
1
=
BC
0
1
=
1
00 01
0
00
1
+ B
0
(+B)=
4
5
1₂ = AB + BC + AC
1
11
3
1.
01 11
1
5
7
1
3
10
7
10
2
6
2
6
BC
0
BC
0
00
.
16
00
1
0
1
0
4
01
1
01
1₂=C+ B
1
5
11
5
In the
11
16 = 1
1
1
3
7
3
7
10
1
10
1
1
2
6
2
15 = A
f3 is read as +, because in the 4-square formed by m0,m2,m6, and m4, the variable A and B
are changing, where as the variable C remains constant as a 0. So it is read as. In the 4-square
formed by mo, m1, m4, m5, A and C are changing but B remains constant as a 0. So it is read as
. So, the resultant expression for f3 is the sum of these two, i.e., +.
6
f₁ is read as + + ,because in the 2-square formed by mo and m4, A is changing from a0
to a 1. Whereas B and C remain constant as a 0. So it s read as
2-square formed
by mo and m₁, C is changing from a 0 to a 1, whereas A and B remain constant as a 0. So it is
read as .In the 2-square formed by mo and m₂ B is changing from a 0 to a 1 whereas A
and C remain constant as a 0. So, it is read as Therefore, the
expression is
>
resultant SOP
++
Some possible maxterm groupings and the corresponding minimal POS expressions read from
the k-map are
DIGITAL LOGIC DESIGN
Page no. 46as
.
BC
fmin=
k-map
0
0
1
1
00
1
00
DIGITAL LOGIC DESIGN
0
4
01
01
1
00
1
5
11
(a) f, = (C)(B)
3
of HotNo
7
11 10
1
1
10
1
1= C + AB + AB
.0
1
6
M3,
In this figure, along the 4-square formed by M₁, M3, M7, M5, A and B are changing from a 0 to
a 1, where as C remains constant as a 1. SO it is read as Along the 4-squad formed by
BC
0
C
1
AOI logic
00
M2, M7, and M6, variables A and C are changing from a 0 to a 1. But B remains constant as a 1.
So it is read as The minimal expression is the product of these two terms, i.e., f₁ = ( )( ).also
in this figure, along the 2-square formed by M4 and M6, variable B is changing from a 0 to a 1,
while variable A remains constant as a 1 and variable C remains constant as a 0. SO, read it
0
4
+C. Similarly, the 2-square formed by M7 andM6 is read as + while the 2-square formed
by M2 and M6 is read as +C. The minimal expression is the product of these sum terms, i.e, f2
=( + )+( + )+(+C)
Ex:Reduce the expression f-Em(0,2,3,4,5,6) using mapping and implement it in AOI logic as
well as in NAND logic.The Sop k-map and its reduction, and the implementation of the minimal
expression using AOI logic and the corresponding NAND logic are shown in figures below
In SOP k-map, the reduction is done as:
1
m5 has only one adjacency m4, so combine m5 and m4 into a square. Along this 2-square
A remains constant as 1 and B remains constant as 0 but C varies from 0 to 1. So read it
as A.
2
m3 has only one adjacency m2, so combine m3 and m2 into a square. Along this 2-square
A remains constant as 0 and B remains constant as 1 but C varies from 1 to 0. So read it
as B.
01
3
m6 can form a 2-square with m2 and m4 can form a 2-square with mo, but observe that by
wrapping the map from left to right mỏ, m4 ,m2 ,m6 can form a 4-square. Out of these m2
andm4 have already been combined but they can be utilized again. So make it. Along this
4-square, A is changing from 0 to 1 and B is also changing from 0 to 1 but C is remaining
constant as 0. so read it as .
1
.
Write all the product terms in SOP form. So the minimal SOP expression is
BC
DL
5
11
AIB KAB
C
3
7
10
(b) f₂ = (A + B)(B+C)(A + C)
01
2
O
NAND logic
6
Page no. 47Four variable k-maps:
Four variable k-map expressions can have 24=16 possible combinations of input variables such
-m15 respectively
-ABCD with minterm designations mo,m₁
+ + +
as
in SOP form & A+B+C+D, A+B+C+
-M₁5 respectively in POS form. It has 2ª=16 squares or cells. The binary number designations of
rows & columns are in the gray code. Here follows 01 & 10 follows 11 called Adjacency
ordering.
AB
CD
00 01 11 10
0
00 ABCD ABCD ABCD ABCD
01 ABCD ABCD ABCD ABCD
12
13
3
SOP form
15
11 ABCD ABCD ABCD ABCD
DIGITAL LOGIC DESIGN
14
11
10 ABCD ABCD ABCD ABCD
10
AB
CD
00
0
01
with maxterms Mo,M₁,-
12
00 A+B+C+DA+B+C+DA+B+C+DA+B+C+D
13
11
01 A+B+C+DA+B+C+DA+B+C+DA+B+C+D
7
POS form
10
15
11 A+B+C+DA+B+C+DA+B+C+DA+B+C+D
11
14
10
10 A+B+C+DA+B+C+DA+B+C+DA+B+C+D
EX: Reduce using mapping the expression Σ m(2, 3, 6, 7, 8, 10, 11, 13, 14).
Start with the minterm with the least number of adjacencies. The minterm m₁3 has no
adjacency. Keep it as it is. The mg has only one adjacency, m₁0- Expand mg into a 2-square
with m₁0 The m, has two adjacencies, m, and m3. Hence m, can be expanded into a
4-square with me, m, and m₂. Observe that, m,, m, m₂, and m3 form a geometric square.
The m₁, has 2 adjacencies, m₁o and m3. Observe that, m₁, m₁o, m3, and m₂ form a
geometric square on wrapping the K-map. So expand m₁, into a 4-square with m₁0, m, and
m₂. Note that, m₂ and m3, have already become a part of the 4-square m,, mg, m₂, and
m3. But if m₁, is expanded only into a 2-square with mo, only one variable is eliminated.
So m₂ and m, are used again to make another 4-square with m₁ and m₁o to eliminate two
variables. Now only m, and m₁4 are left uncovered. They can form a 2-square that
eliminates only one variable. Don't do that. See whether they can be expanded into a larger
square. Observe that, m₂, má, m₁4, and m₁0 form a rectangle. So me and m₁4 can be
expanded into a 4-square with m, and m₁o. This eliminates two variables.
Page no. 48Grouping s is
(a) mo, m16 =
(b) m₂, m18 =
(c) m₁. m6 m20 m22 =
(d) ms, m,, m13, mis, m21,
BC
00
DE
01
BCDE
BCDE
11
10
DIGITAL LOGIC DESIGN
23,
m29. m31 = CE
(e) mg, mg, mio, m11, M24, 25,
m26 m27 = BC
00
AB
0
2
12
BCE
CD
00
01
11
15
11
Five variable k-map:
Five variable k-map can have 25 =32 possible combinations of input variable as
E,--------ABCDE with minterms mo, m₁-----m31 respectively in SOP &
A+B+C+D+E, A+B+C+
+ + + + with maxterms Mo,M1,
M31 respectively in POS form. It has 25-32 squares or cells of the k-map are divided into 2
blocks of
16 squares each.The left block represents minterms from mo to m₁5 in which A is a 0, and the
right block represents minterms from m16 to m31 in which A is 1.The 5-variable k-map may
contain 2-squares, 4-squares, 8-squares, 16-squares or 32-squares involving these two blocks.
Squares are also considered adjacent in these two blocks, if when superimposing one block on
top of another, the squares coincide with one another.
Some possible 2-squares in a five-variable map are mo, m16 m₂, m18; ms, m21;
mis, m31; M1, M27.
Some possible 4-squares are mo, m₂, m16, mis mo, m₁, M16, M17
m13, m15, m29, m31; ms, m13, M21, M29-
Some possible 8-squares are mo, m₁, m3, m₂, m16, m17, m19, m18
m16 m20 m28, M24; ms, m7, m13, m15, m21, M23, m29, m31.
The squares are read by dropping out the variables which change. Some possible
0
01 11 10
00
6
O
14
4
10
12
01
1
5
13
9
11 10
1
10 1.
1
f = ABCD + ABD + AC + BC + CD
15
BC
14
12
00
1
14
DE
01
10
10
Mo, M16 = B + C + D + E
M₂, M18 B + C + D +
M4, M6, M20 M22
B + C + E
M5, M7, M13, M15, M21, M23, M29,
M31 =C+E
M24, M25, M26
Mg, Mg, M10 M11
M27
B + C
00
16
20
28
24
T
=
01
1
17
N
25
11
19
23
31
10
18
30
mo, m4, m16 M20
26
mo, m4, M12, Mg,
Page no. 49Ex: F-Em(0,1,4,5,6,13,14,15,22,24,25,28,29,30,31) is SOP
POS is F=TM(2,3,7,8,9,10,11,12,16,17,18,19,20,21,23,26,27)
The reduction is done as
1. There is no isolated 1s
2. M₁2 can go only with m13. Form a 2-square which is read as A'BCD'
3. Mo can go with m2,m16 and m18. so form a 4-square which is read as B'C'E'
4. M20,m21,m17 and m₁6 form a 4-square which is read as AB'D'
5. M2,m3,m18,m19,m10,m11,m26 and m27 form an 8-square which is read as C'd
6. Write all the product terms in SOP form.
So the minimal expression is
Fmin A'BCD+B'C'E'+AB'D'+C'D(16 inputs)
The real minimal expression is the minimal of the SOP and POS forms.
4.M8
5. M28
BC
6.M30
DE
00
01
DIGITAL LOGIC DESIGN
11
10
00
17
1
4
8
0
01 11
1
5
13
1
7
15
11
10
1
6
In the POS K-map ,the reduction is done as:
1. There are no isolated Os
14
10
BC
DE
00
00 1
01 1
11
10
20
28
f = ABCD + BCE + ABD + CD
01
1
7. Sum terms in POS form. So the minimal expression in POS is
Fmin= A'BcD'+B'C'E'+AB'D'+C'D
1
25
11
1
31
27
M₁ can go only with M₁. So, make a 2-square, which is read as (A + B + D + Ē).
M, can go with Ms, My, and M, to form a 4-square, which is read as (A + B + C).
3.
10
1
k
T
Page no. 50BC
Six variable k-map:
O
CD
1
DE
00
CD
01
11
10
DIGITAL LOGIC DESIGN
EF
00
01
11
10
EF
00
01
11
00
10
0
00
0
01 11
0
00
0
12
0
01
-S
01
13
0
9
37
451
7
11
11
11
Six variable k-map can have 26 =64 combinations as
---ABCDEF with minterms mo, m₁-----m63 respectively in SOP & (A+B+C+D+E+F),
+ + + + + ) with maxterms Mo,M₁, ---M63 respectively in POS form. It has
26=64 squares or cells of the k-map are divided into 4 blocks of 16 squares each.
15
10
11
0
39
O
14
10
10
10
BC
14
10
DE
00
01
f=(A+B+D+EXA+B+CXB + C + D)(A + B + D)(C + D)
11
10
CD
CD
00
===========
0
EF
EF
O
20
00
00
20
28
24
52
01
60
1
0
29
0
21
01
21
29
11 10
19
25
01
0
23
11
11
23
31
O
27
O
55
10
10
22
30
25
62
Some possible groupings in a six variable k-map
Don't care combinations:For certain input combinations, the value of the output is unspecified
either because the input combinations are invalid or because the precise value of the output is of
no consequence. The combinations for which the value of experiments are not specified are
called don't care combinations are invalid or because the precise value of the output is of no
consequence. The combinations for which the value of expressions is not specified are called
don't care combinations or Optional Combinations, such expressions stand incompletely
specified. The output is a don't care for these invalid combinations.
Ex: In XS-3 code system, the binary states 0000, 0001, 0010,1101,1110,1111 are unspecified. &
never occur called don't cares.
A standard SOP expression with don't cares can be converted into a standard POS
form by keeping the don't cares as they are & writing the missing minterms of the SOP form as
the maxterms of the POS form viceversa.
Don't cares denoted by _X' or _9°
Page no. 51Ex:f-Em(1,5,6,12,13,14)+d(2,4)
Or f= M(0,3,7,9,10,11,15).лd(2,4)
SOP minimal form fmin=
POS minimal form fmin=(B+D)( +B)( +D)
= + + + + ( +
AB
CD
00
5
01 X
11
00
10
1
0
12
8
01 11 10
1
X
1
1
5
13
9
DIGITAL LOGIC DESIGN
7
+B +
15
11
1
1
10
(a) f = BC + BD + ACD
AB
EPI
ABC
AB
00
00 0
01 X
EPI
ACD
11
CD
CD
00
01
11
0
10 0 0 0
10
00
01
1
Prime implicants, Essential Prime implicants, Redundant prime implicants:
Each square or rectangle made up of the bunch of adjacent minterms is called a subcube. Each of
these subcubes is called a Prime implicant (PI). The PI which contains at leastone which cannot
be covered by any other prime implicants is called as Essential Prime implicant (EPI).The PI
whose each 1 is covered at least by one EPI is called a Redundant Prime implicant (RPI). A PI
which is neither an EPI nor a RPI is called a Selective Prime implicant (SPI).
The function has unique MSP comprising EPI is
F(A,B,C,D)= CD+ABC+A D + B
0
The RPI_BD' may be included without changing the function but the resulting expression would
not be in minimal SOP(MSP) form.
4
5
12
13
(b) f = (B + D)(A + B)(C+ D)
1
11
0
1
0
C
01 11
13
9
10
1
3
7
X
x
11
5
15
14
10 . ΕΡΙ
ACD
1
BD
A Do
!D
(c) NOR logic
6
14
1010
10
RPI
BD
-EPI
ABC
Essential and Redundant Prime Implicants
Page no. 52F(A,B,C,D)=Em(0,4,5,10,11,13,15) SPI are marked by dotted squares, shows
MSP form of a function need not be unique.
(A) (4,5) &(13,15)
(B) (5,13) & (13,15).
(C) (5,13) & (15,11) --
EPI
ACD
(OR)
SPI
ABC
AB
SPI
BCD
DIGITAL LOGIC DESIGN
CD
8
00
01
11
10
00
E
0
-B +ABD
-B D+ABD
B D+ACD
01 11
1
8
12 LJ13
41!
E
9
M(5,6,7,9,10,11,13,14,15)
3
7
15
$1
10
2
Essential and Selective Prime Implicants
Here, the MSP form is obtained by including two EPI's & selecting a set of SPI's to cover
remaining uncovered minterms 5,13,15. & these can be covered as
6
14
1
10
F(A,B,C,D)= +A C---------EPI's + B +ABD
F(A,B,C,D)= +A C-----EPI's +
(OR)
F(A,B,C,D)=
+A C---------EPI's +
False PI's Essential False PI's, Redundant False PI's & Selective False PI's:
The maxterms are called falseminterms. The PI's is obtained by using the maxterms are
called False PI's (FPI). The FPI which contains at least one _0' which can't be covered by only
other FPI is called an Essential False Prime implicant (ESPI)
F(A,B,C,D)= Σm(0,1,2,3,4,8,12)
SPI
ABD
SPI
ACD
· ΕΡΙ
ABC
B D+ABD
=
Fmin= ( + )( + )(+)(+)
All the FPI, EFPI's as each of them contain atleast one _0' which can't be covered by any other
FPI
B D+ACD
Page no. 53EFPI
B+D
EFPI
●
DIGITAL LOGIC DESIGN
AB
EFPI
A+B+C
EFPI
Ā+C+D
AB
Em(0,1,4,5)=+C+A+AC
00
CD
01
11
10
CD
00
01
11
00 10
lool
0
10 0
12
O
4
4
Consider Function F(A,B,C,D)= M(0,1,2,6,8,10,11,12)
lo
12
8
01
O
O
O
01
13
0
Essential False Prime implicants
1
5
5
13
11
9
O
O
O
11
15
0
3
3
7
15
7
11
11
10
O
O
O
10
0
0
0
14
10
6
6
14
10
EFPI
B+C
EFPI
A + C
RFPI
B+D
Essential and Redundant False Prime Implicants
Mapping when the function is not expressed in minterms (maxterms):
An expression in k-map must be available as a sum (product) of minterms (maxterms). However
if not so expressed, it is not necessary to expand the expression algebraically into its minterms
(maxterms). Instead, expansion into minterms (maxterms) can be accomplished in the process of
entering the terms the expression on the k-map.
Limitations of Karnaugh maps:
EFPI
A+ C + D
Convenient as long as the number of variables does not exceed six.
Manual technique, simplification process is heavily dependent on the human abilities.
Quine-Mccluskey Method:
It also known as Tabular method. It is more systematic method of minimizing expressions
of even larger number of variables. It is suitable for hand computation as well as computation by
machines i.e., programmable. . The procedure is based on repeated application of the combining
theorem.
EFPI
A+B+C
PA+P =P (P is set of literals) on all adjacent pairs of terms, yields the set of all PI's from which
a minimal sum may be selected.
Consider expression
Page no. 54First, second terms & third, fourth terms can be combined
(+)+ (C+ )= +A
Reduced to
( + )=
The same result can be obtained by combining mo& m4 & m₁&m5 in first step & resulting terms
in the second step.
Procedure:
● Decimal Representation
● Don't cares
PI chart
EPI
●
●
● Dominating Rows & Columns
Determination of Minimal expressions in comples cases.
●
Branching Method:
EXAMPLE 3.29 Obtain the set of prime implicants for the Boolean expression
f = m(0, 1, 6, 7, 8, 9, 13, 14, 15) using the tabular method.
Solution
Group the minterms in terms of the number of Is present in them and write their binary
designations. The procedure to obtain the prime implicants is shown in Table 3.3.
Table 3.3
Index 0
Index 1
Index 2
Index 3
Index 4
Column 1
Minterm Binary designation
0
I
8
6
9
7
13
14
15
DIGITAL LOGIC DESIGN
0000✔
0001/
1000✔
0110/
1001/
0111✔
1101✔
1110✔
1111✔
Example 3.29
Column 2
0, 1 (1)
0.8 (8)
1,9 (8)
8,9 (1)
6,7 (1)
6. 14 (8)
9, 13 (4)
7, 15 (8)
13, 15 (2)
14, 15 (1)
ABCD
Column 3
ABCD
000✔ 0, 1,8,9 (1,8)-00-Q
-000✔
-001
100-✔ 6, 7, 14, 15 (1, 8)-11-P
011-✔
-110 ✓
1-01 S
-111✔
11-1 R
111-✔
********* ****
Page no. 55Comparing the terms of index 0 with the terms of index 1 of column 1, m, (0000) is combined
with m, (0001) to yield 0, 1 (1), i.e. 000 -. This is recorded in column 2 and 0000 and 0001 are
checked off in column 1. m, (0000) is combined with mg (1000) to yield 0, 8 (8), i.e. - 000. This is
recorded in column 2 and 1000 is checked off in column 1. Note that 0000 of column 1 has already
been checked off. No more combinations of terms of index 0 and index 1 are possible. So, draw a
line below the last combination of these groups, i.e. below 0, 8 (8), - 000 in column 2. Now 0, 1
(1), i.e. 000 - and 0, 8 (8), i.e. - 000 are the terms in the first group of column 2.
Comparing the terms of index 1 with the terms of index 2 in column 1, m, (0001) is combined
with m,(1001) to yield 1, 9 (8), i.e. - 001. This is recorded in column 2 and 1001 is checked off in
column 1 because 0001 has already been checked off. m (1000) is combined with m,(1001) to
yield 8,9 (1), i.e. 100-. This is recorded in column 2. 1000 and 1001 of column 1 have already
been checked off. So, no need to check them off again. No more combinations of terms of index 1
and index 2 are possible. So, draw a line below the last combination of these groups, i.e. 8, 9 (1),
--001 in column 2. Now 1,9 (8), i.e.-001 and 8,9 (1), i.e. 100- are the terms in the second group
of column 2.
Similarly, comparing the terms of index 2 with the terms of index 3 in column 1,
m (0110) and m,(0111) yield 6, 7 (1), i.e. 011-. Record it in column 2 and check off
6(0110) and 7(0111).
m (0110) and m, 4(1110) yield 6, 14 (8), i.e. -110. Record it in column 2 and check off
6(0110) and 14(1110).
m,(1001) and m₁3 (1101) yield 9, 13 (4), i.e. 1-01. Record it in column 2 and check off
9(1001) and 13(1101).
So, 6, 7 (1), i.e. 011-, and 6, 14 (8), i.e. -110 and 9, 13 (4), i.e. 1-01 are the terms in group 3 of
column 2. Draw a line at the end of 9, 13 (4), i.e. 1-01.
Also, comparing the terms of index 3 with the terms of index 4 in column 1,
m,(0111) and m,,(1111) yield 7, 15 (8), i.e. -111. Record it in column 2 and check off
7(0111) and 15(1111).
m₁3(1101) and m, 5(1111) yield 13, 15 (2), i.e. 11-1. Record it in column 2 and check off
13 and 15.
m₁4(1110) and m₁5(1111) yield 14, 15 (1), i.e. 111-. Record it in column 2 and check off
14 and 15.
So, 7, 15 (8), i.e. -111, and 13, 15 (2), i.e. 11-1 and 14, 15 (1), i.e. 111- are the terms in group 4
of column 2. Column 2 is completed now.
DIGITAL LOGIC DESIGN
Page no. 56Comparing the terms of group 1 with the terms of group 2 in column 2, the terms 0, 1 (1), i.e.
000 and 8,9 (1), i.e. 100-are combined to form 0, 1, 8, 9 (1, 8), i.e. -00-. Record it in group 1 of
column 3 and check off 0, 1 (1), i.e. 000-, and 8, 9 (1), i.e. 100- of column 2. The terms 0, 8 (8),
i.e. -000 and 1, 9 (8), i.e. -001 are combined to form 0, 1, 8, 9 (1, 8), i.e. -00-. This has already
been recorded in column 3. So, no need to record again. Check off 0, 8 (8), i.e. -000 and 1,9 (8),
i.e. -001 of column 2. Draw a line below 0, 1, 8, 9 (1, 8), i.e. -00-. This is the only term in group 1
of column 3. No term of group 2 of column 2 can be combined with any term of group 3 of
column 2. So, no entries are made in group 2 of column 2.
Comparing the terms of group 3 of column 2 with the terms of group 4 of column 2, the
terms 6, 7 (1), i.e. 011-, and 14, 15 (1), i.e. 111- are combined to form 6, 7, 14, 15 (1, 8), i.e.
-11-. Record it in group 3 of column 3 and check off 6, 7 (1), i.e. 011- and 14, 15 (1), i.e. 111-of
column 2. The terms 6, 14 (8), i.e. -110 and 7, 15 (8), i.e. -111 are combined to form 6, 7, 14, 15
(1,8), i.e.-11-. This has already been recorded in column 3; so, check off 6, 14 (8), i.e. -110 and
7, 15 (8), i.e. -111 of column 2.
Observe that the terms 9, 13 (4), i.e. 1-01 and 13, 15 (2), i.e. 11-1 cannot be combined with
any other terms. Similarly in column 3, the terms 0, 1, 8, 9 (1, 8), i.e. -00- and 6, 7, 14, 15 (1, 8),
i.e.-11-cannot also be combined with any other terms. So, these 4 terms are the prime implicants.
The terms, which cannot be combined further, are labelled as P, Q, R, and S. These form the
set of prime implicants.
EX:
Obtain the minimal expression for f = Σ m(1, 2, 3, 5, 6, 7, 8, 9, 12,
13, 15) using the tabular method.
Solution
The procedure to obtain the set of prime implicants is illustrated in Table 3.4.
Index 1
Index 2
Index 3
Index 4
Step 1
1✔
2✔
8✓
3✓
5√
6✔
9✔
12 ✔
7✔
13✔
15✔
DIGITAL LOGIC DESIGN
Table 3.4 Example 3.30
Step 2
1,3 (2) ✔
1,5 (4) ✔
1,9 (8) ✔
2, 3 (1) ✔
2, 6 (4) ✔
8,9 (1) ✔
8, 12 (4) ✔
3,7 (4) ✔
5,7 (2) ✔
5, 13 (8)✔
6,7 (1) ✔
9. 13 (4) ✔
12, 13 (1) ✔
7, 15 (8) ✔
13, 15 (2) ✔
Step 3
1, 3, 5, 7 (2, 4)
1, 5, 9, 13 (4, 8)
2, 3, 6, 7 (1, 4)
8, 9, 12, 13 (1,4)
5, 7, 13, 15 (2,8)
T
S
R
P
Page no. 57The non-combinable terms P, Q, R, S and T are recorded as prime implicants.
P→ 5, 7, 13, 15 (2, 8) = X 1 X 1 = BD
(Literals with weights 2 and 8, i.e. C and A are deleted. The lowest minterm is m,(5 = 4 + 1). So,
literals with weights 4 and 1, i.e. B and D are present in non-complemented form. So, read it as BD.)
Q→ 8, 9, 12, 13 (1,4)= 1 X 0 X = AC
(Literals with weights 1 and 4, i.e. D and B are deleted. The lowest minterm is mg. So, literal with
weight 8 is present in non-complemented form and literal with weight 2 is present in complemented
form. So, read it as AC.)
R→ 2, 3, 6, 7 (1,4)=0X 1 X = AC
(Literals with weights 1 and 4, i.e. D and B are deleted. The lowest minterm is m₂. So, literal with
weight 2 is present in non-complemented form and literal with weight 8 is present in complemented
form. So, read it as AC.)
S → 1, 5, 9, 13 (4, 8) = X X 0 1 = CD
(Literals with weights 4 and 8, i.e. B and A are deleted. The lowest minterm is m,. So, literal with
weight 1 is present in non-complemented form and literal with weight 2 is present in complemented
form. So, read it as CD.)
T→ 1, 3, 5, 7 (2, 4) = 0 XX 1 = ĀD
(Literals with weights 2 and 4, i.e. C and B are deleted. The lowest minterm is 1. So, literal with
weight 1 is present in non-complemented form and literal with weight 8 is present in complemented
form. So, read it as ĀD.)
The prime implicant chart of the expression
is as shown in Table 3.5. It consists of 11 columns corresponding to the number of minterms and 5
rows corresponding to the prime implicants P, Q, R, S, and T generated. Row R contains four xs at
the intersections with columns 2, 3, 6, and 7, because these minterms are covered by the prime
implicant R. A row is said to cover the columns in which it has xs. The problem now is to select a
minimal subset of prime implicants, such that each column contains at least one x in the rows
corresponding to the selected subset and the total number of literals in the prime implicants selected
is as small as possible. These requirements guarantee that the number of unions of the selected
prime implicants is equal to the original number of minterms and that, no other expression containing
fewer literals can be found.
*P→ 5, 7, 13, 15 (2,8)
*Q→ 8, 9, 12, 13 (1,4)
*R2, 3, 6, 7 (1,4)
S→ 1, 5, 9, 13 (4,8)
T1, 3, 5, 7 (2, 4)
f = m(1, 2, 3, 5, 6, 7, 8, 9, 12, 13, 15)
DIGITAL LOGIC DESIGN
Table 3.5 Example 3.30: Prime implicant chart
✓
2
1
X
X
3
X
5
X
X X
6
X
7
X
X
8
9
X
12
13
XX
X
15
X
Page no. 58In the prime implicant chart of Table 3.5, m, and m, are covered by R only. So, R is an essential
prime implicant. So, check off all the minterms covered by it, i.e. m₂, m3, m., and m,. Q is also an
essential prime implicant because only Q covers mg and m₁2. Check off all the minterms covered
by it, i.e. mg, mg, m1₁2, and m₁3. P is also an essential prime implicant, because m₁5 is covered only
by P. So check off m₁5, mg, m., and m₁3 covered by it. Thus, only minterm I is not covered. Either
row S or row T can cover it and both have the same number of literals. Thus, two minimal expressions
are possible.
or
DIGITAL LOGIC DESIGN
P+Q+R+S=BD + AC + AC + CD
P+Q+R+T=BD + AC + AC + AD
Page no. 59Combinational Logic
●
n inputs
Logic circuits for digital systems may be combinational or sequential.
A combinational circuit consists of input variables, logic gates, and output variables.
Design Procedure:
UNIT-III
COMBINATIONAL CIRCUITS
Combinational
circuit
DIGITAL LOGIC DESIGN
For n input variables,there are 2" possible combinations of binary input variables For
each possible input Combination ,there is one and only one possible output combination.A
combinational circuit can be described by m Boolean functions one for each output
variables. Usually the input s comes from flip-flops and outputs goto flip-flops.
m outputs
1. The problem is stated
2. The number of available input variables and required output variables is
determined. 3. The input and output variables are assigned lettersymbols.
4.The truth table that defines the required relationship between inputs and outputs is derived.
5.The simplified Boolean function for each output is obtained.
Page no. 60Adders:
Digital computers perform variety of information processing tasks,the one is arithmetic
operations. And the most basic arithmetic operation is the addition of two binary digits.i.e, 4 basic
possible operations are:
0+0=0,0+1=1,1+0=1,1+1=10
The first three operations produce a sum whose length is one digit, but when augends and addend
bits are equal to 1,the binary sum consists of two digits.The higher significant bit of this result is
called a carry.A combinational circuit that performs the addition of two bits is called a half-
adder. One that performs the addition of 3 bits (two significant bits & previous carry) is called a
full adder.& 2 half adder can employ as a full-adder.
The Half Adder: A Half Adder is a combinational circuit with two binary inputs (augends and
addend bits and two binary outputs (sum and carry bits.) It adds the two inputs (A and B) and
produces the sum (S) and the carry (C) bits. It is an arithmetic operation of addition of two single
bit words.
Inputs
A B
S
O
O
0
O
1
1
O
1
1
O
(a) Truth table
1
1
A
B
PD
(a)
Outputs
с
0
O
0
1
DIGITAL LOGIC DESIGN
The Sum(S) bit and the carry (C) bit, according to the rules of binary addition, the sum (S) is the
X-OR of A and B (It represents the LSB of the sum). Therefore,
S=AB+AAⓇB
The carry (C) is the AND of A and B (it is 0 unless both the inputs are 1). Therefore,
C=AB
A half-adder can be realized by using one X-OR gate and one AND gate a
S
B
Half-adder
B
Logic diagrams of half-adder
(b) Block diagram
S
C.
(b)
S
Page no. 61NAND LOGIC:
NOR Logic:
The Full Adder:
S = AB + AB=AB + AA + AB + BB
= A(A + B) + B(A + B)
= A AB + B. AB
= A AB-B-AB
C=AB= AB
DIGITAL LOGIC DESIGN
AB
A AB
B
B
B-AB
Logic diagram of a half-adder using only 2-input NAND gates.
S = AB + AB=AB+ AĀ + AB + BB
= A(A + B) + B(A + B)
= (A + B)(A + B)
= A + B + A+B
C=AB=AB= A + B
B
A+B
A+B
Logic diagram of a half-adder using only 2-input NOR gates.
A Full-adder is a combinational circuit that adds two bits and a carry and outputs a sum
bit and a carry bit. To add two binary numbers, each having two or more bits, the LSBs can be
added by using a half-adder. The carry resulted from the addition of the LSBs is carried over to
the next significant column and added to the two bits in that column. So, in the second and
higher columns, the two data bits of that column and the carry bit generated from the addition in
the previous column need to be added.
The full-adder adds the bits A and B and the carry from the previous column called the
carry-in Cin and outputs the sum bit S and the carry bit called the carry-out Cout. The variable S
gives the value of the least significant bit of the sum. The variable Cout gives the output carry.The
Page no. 62eight rows under the input variables designate all possible combinations of 1s and Os that these
variables may have. The 1s and Os for the output variables are determined from the arithmetic
sum of the input bits. When all the bits are Os, the output is 0. The S output is equal to 1 when
only 1 input is equal to 1 or when all the inputs are equal to 1. The Cout has a carry of 1 if two or
three inputs are equal to 1.
and
A
0
0
0
1
1
Inputs
DIGITAL LOGIC DE
B Cin
0
0
A
B
C₂
1
0
O
1
0
1
0
1
0
1
0
1
Sum
S
0
1
(a) Truth table
0
1
1
O
1
0
S = ABCin+ ABCin+ ABCin+ ABCin
#
Cout= ABCin+ ABCin+ ABCin+ABCin
S AB+ Cin
HA
Full-adder.
From the truth table, a circuit that will produce the correct sum and carry bits in response to
every possible combination of A,B and Cin is described by
Half-adder
Carry
Cout
0
0
0
Cout= ACin + BCin + AB
0
The sum term of the full-adder is the X-OR of A,B, and Cin, i.e, the sum bit the modulo
sum of the data bits in that column and the carry from the previous column. The logic diagram
of the full-adder using two X-OR gates and two AND gates (i.e, Two half adders) and one OR
gate is
C=AB
AB
AⓇB
Half-adder
A B
ट
Can
Full-adder
(b) Block diagram
(A + B)Cin
HA
!S=A@BOC
The block diagram of a full-adder using two half-adders is:
D
S
-COLR
Logic diagram of a full-adder using two half-adders.
Cout= (AB)Cin + AB
Cout= (AB)C + AB
S = AⓇB C
Block diagram of a full-adder using two half-adders.
ge no. 63Even though a full-adder can be constructed using two half-adders, the disadvantage is that the
bits must propagate through several gates in accession, which makes the total propagation delay
greater than that of the full-adder circuit using AOI logic.
The Full-adder neither can also be realized using universal logic, i.e., either only NAND gates or
only NOR gates as
NAND Logic:
B
Then
G₂
B
B
B
ED
ED
D
A B = A. AB B. AB
DIGITAL LOGIC DESIGN
S = AⓇB Cin= (AB) (AB)Cin Cin. (A + B)Cin
Cout=Cin(A + B) + AB = Cin (A + B). AB
S
A
H
B
A
H
Cin
B
H
Cin
Sum and carry bits of a full-adder using AOI logic.
DDDD
(AB)
Cout
AB
Logic diagram of a full-adder using only 2-input NAND gates.
S
Cout
Page no. 64NOR Logic:
Subtractors:
Then
The Half-Subtractor:
AB= (A + B) + A + B
S = AⓇB÷Cin= (AB) + Cin +(AB) + Cin
Cout= AB +C₁n(AB) = A + B + Cin + A B
Œ
DIGITAL LOGIC DESIGN
AⓇB
Logic diagram of a full-adder using only 2-input NOR gates.
The subtraction of two binary numbers may be accomplished by taking the complement
of the subtrahend and adding it to the minuend. By this, the subtraction operation becomes an
addition operation and instead of having a separate circuit for subtraction, the adder itself can be
used to perform subtraction. This results in reduction of hardware. In subtraction, each
subtrahend bit of the number is subtracted from its corresponding significant minuend bit to form
a difference bit. If the minuend bit is smaller than the subtrahend bit, a 1 is borrowed from the
next significant position., that has been borrowed must be conveyed to the next higher pair of
bits by means of a signal coming out (output) of a given stage and going into (input) the next
higher stage.
A Half-subtractor is a combinational circuit that subtracts one bit from the other and
produces the difference. It also has an output to specify if a 1 has been borrowed.. It is used to
subtract the LSB of the subtrahend from the LSB of the minuend when one binary number is
subtracted from the other.
A Half-subtractor is a combinational circuit with two inputs A and B and two
outputs d and b. d indicates the difference and b is the output signal generated that informs the
next stage that a 1 has been borrowed. When a bit B is subtracted from another bit A, a
difference bit (d) and a borrow bit (b) result according to the rules given as
Inputs
A
0
1
1
O
B
1010
Outputs
d
0
1
0
1
(a) Truth table
b
0
0
Cout
A
B
Half-subtractor
(b) Block diagram
Half-subtractor.
Page no. 65The output borrow b is a 0 as long as A2B. It is a 1 for A=0 and B=1. The d output is the result
of the arithmetic operation2b+A-B.
A circuit that produces the correct difference and borrow bits in response to every possible
combination of the two 1-bit numbers is, therefore,
That is, the difference bit is obtained by X-OR ing the two inputs, and the borrow bit is obtained
by ANDing the complement of the minuend with the subtrahend.Note that logic for this exactly
the same as the logic for output S in the half-adder.
A-
B
NOR Logic:
d=AB+A AB and b=A B
d
b
DIGITAL LOGIC DESIGN
A
D
B
Logic diagrams of a half-subtractor.
d=AB=A AB-B-AB
b = ĀB = B(A + B) = B(AB) = B. AB
D
B
A half-substractor can also be realized using universal logic either using only NAND gates or
using NOR gates as:
NAND Logic:
A AB
B. AB
A-
b
Logic diagram of a half-subtractor using only 2-input NAND gates.
d=AB=AB + AB = AB + BB+ AB + AĀ
= B(A + B) + Ā(A + B)= B+A+B+ A+ A+B
d = ĀB = Ā(A + B) = A(A + B) = A + (A + B)
b
d
Page no. 66A
B
The Full-Subtractor:
and
Inputs
A B b₁
DIGITAL LOGIC DESIGN
The half-subtractor can be only for LSB subtraction. IF there is a borrow
during the subtraction of the LSBs, it affects the subtraction in the next higher column; the
subtrahend bit is subtracted from the minuend bit, considering the borrow from that column used
for the subtraction in the preceding column. Such a subtraction is performed by a full-subtractor.
It subtracts one bit (B) from another bit (A), when already there is a borrow bị from this column
for the subtraction in the preceding column, and outputs the difference bit (d) and the borrow
bit(b) required from the next d and b. The two outputs present the difference and output borrow.
The 1s and Os for the output variables are determined from the subtraction of A-B-b₁.
0 0
0
0 0
1
0 1 0
0
1
1
0 0
1
1
1 1
Logic diagram of a half-subtractor using only 2-input NOR gates.
FOTO
0
1 0
1
Difference
d
0
1
1
0
A+ A+B
D
B+A+B
1
(a) Truth table
Borrow
b
0
1
1
B
b₁
مسطر
Full-subtractor
(b) Block diagram
d
Full-subtractor.
From the truth table, a circuit that will produce the correct difference and borrow bits in response
to every possiblecombinations of A,B and bi is
d = ABb₁ + AB b₁ +ABb₁ +ABb;
=b,(AB + AB) + b(AB+ ĀB)
=b₁(AⓇB) + b(A + B) = A + B bi
A full-subtractor can be realized using X-OR gates and AOI gates as
b = ABb₁ + AB 5₁ + ĀBb; + ABb = AB(b; + b) + (AB + AB)b
= ĀB + (AⓇB)b,
d
Page no. 67A
B
b₂
NOR Logic:
Logic diagram of a full-subtractor.
The full subtractor can also be realized using universal logic either using only NAND gates or
using NOR gates as:
NAND Logic:
b,
b
d = AⓇB÷b₁ = (AⓇB) Ⓡb₁ = (A + B)(A + B)b, b, (A + B)b;
b = ĀB + b₂( A Ⓡ B) = ĀB + b¡ (A + B)
= AB - b, (AB) = B(A + B) · b¡ (б₂ + (A & B)]
= B-AB-b₁[b, - (AB)]
d = AⓇBb₁ = (A + B) bi
= (AB)b; +(AB)b,
= [(AB) + (AB)b; ][b; +(AB)b;]
Logic diagram of a full-subtractor using only 2-input NAND gates.
= (AB) + (AⓇB)+b; +b; +(A + B) + b₁
= (AⓇB) + (AⒸB) +b; +b; + (AⒸB) + b₁
b= AB + b (AB)
= Ā(A + B) + (A + B)[(A + B) + b;]
= A + (A + B)+(AB) + (AB) + b₁
مسطرb₁
Binary Parallel Adder:
Da
19
Logic diagram of a full subtractor using only 2-input NOR gates.
FA₁
S₁
A binary parallel adder is a digital circuit that adds two binary numbers in parallel form
and produces the arithmetic sum of those numbers in parallel form. It consists of full adders
connected in a chain, with the output carry from each full-adder connected to the input carry of
the next full-adder in the chain.
C3
The interconnection of four full-adder (FA) circuits to provide a 4-bit parallel adder. The
augends bits of A and addend bits of B are designated by subscript numbers from right to left,
with subscript 1 denoting the lower -order bit. The carries are connected in a chain through the
full-adders. The input carry to the adder is Cin and the output carry is C4. The S output generates
the required sum bits. When the 4-bit full-adder circuit is enclosed within an IC package, it has
four terminals for the augends bits, four terminals for the addend bits, four terminals for the sum
bits, and two terminals for the input and output carries. AN n-bit parallel adder requires n-full
adders. It can be constructed from 4-bit, 2-bit and 1-bit full adder ICs by cascading several
packages. The output carry from one package must be connected to the input carry of the one
with the next higher-order bits. The 4-bit full adder is a typical example of an MSI function.
FA3
C₂
D[
D
FA₂
C₁
ممك
B.
FA₁
S₁
Logic diagram of a 4-bit binary parallel adder.
d
Cin
Ripple carry adder:
In the parallel adder, the carry out of each stage is connected to the carry-in of
the next stage. The sum and carry-out bits of any stage cannot be produced, until sometime after
the carry-in of that stage occurs. This is due to the propagation delays in the logic circuitry,which lead to a time delay in the addition process. The carry propagation delay for each full-
adder is the time between the application of the carry-in and the occurrence of the carry-out.
The 4-bit parallel adder, the sum (S₁) and carry-out (C₁) bits given by FA₁ are not valid, until
after the propagation delay of FA₁. Similarly, the sum S₂ and carry-out (C₂) bits given by FA2 are
not valid until after the cumulative propagation delay of two full adders (FA₁ and FA₂), and so
on. At each stage ,the sum bit is not valid until after the carry bits in all the preceding stages are
valid. Carry bits must propagate or ripple through all stages before the most significant sum bit is
valid. Thus, the total sum (the parallel output) is not valid until after the cumulative delay of all
the adders.
The parallel adder in which the carry-out of each full-adder is the carry-in to the next most
significant adder is called a ripple carry adder.. The greater the number of bits that a ripple carry
adder must add, the greater the time required for it to perform a valid addition. If two numbers
are added such that no carries occur between stages, then the add time is simply the propagation
time through a single full-adder.
4-Bit Parallel Subtractor:
The subtraction of binary numbers can be carried out most conveniently by means of
complements, the subtraction A-B can be done by taking the 2's complement of B and adding
it to A. The 2's complement can be obtained by taking the 1's complement and adding 1 to the
least significant pair of bits. The 1's complement can be implemented with inverters as
B₂ A₂
B3 A3
B₂ A₂
B₁ A₁
Cout 4
FA4
S₁
Cin 4 Cout 3
Binary-Adder Subtractor:
FA3
Cin3 Cout 2
FA₂
Cin 2 Cout 1
S₂
S₂
Logic diagram of a 4-bit parallel subtractor.
FA₁
S₁
Cn1=1
A 4-bit adder-subtractor, the addition and subtraction operations are combined into
one circuit with one common binary adder. This is done by including an X-OR gate with each
full-adder. The mode input M controls the operation. When M=0, the circuit is an adder, and
when M=1, the circuit becomes a subtractor. Each X-OR gate receives input M and one of the
inputs of B. When M=0, P=B.The full-adder receives the value of B, the input carry is 0and the circuit performs A+B. when Bel=B' and C₁=1. The B inputs are complemented and
a 1 is through the input carry. The circuit performs the operation A plus the 2's complement of B.
B₁
B₂
1929
C₁
FA3
FA₂
FA4
An
B
C₁
SA
A₂
HA
C3
B3
The Look-Ahead -Carry Adder:
S₂
S₁
S3
Logic diagram of a 4-bit binary adder-subtractor.
In parallel-adder,the speed with which an addition can be performed is governed by
the time required for the carries to propagate or ripple through all of the stages of the adder. The
look-ahead carry adder speeds up the process by eliminating this ripple carry delay. It examines
all the input bits simultaneously and also generates the carry-in bits for all the stages
simultaneously.
B₁
The method of speeding up the addition process is based on the two additional
functions of the full-adder, called the carry generate and carry propagate functions.
Consider one full adder stage; say the nth stage of a parallel adder as shown in fig.
we know that is made by two half adders and that the half adder contains an X-OR gate to
produce the sum and an AND gate to produce the carry. If both the bits An and B₁ are 1s, a carry
has to be generated in this stage regardless of whether the input carry Cin is a 0 or a 1. This is
called generated carry, expressed as G₁= An.Bn which has to appear at the output through the OR
gate as shown in fig.
A,B=G₁
A₁B₁=P
FA₁
HA
M
Co=Pn. Cn
c. D
C+1 Con=(AB)C+ A,B
S₁ = A, B, C,
A full adder (nth stage of a parallel adder).
Thereis another possibility of producing a carry out. X-OR gate inside the half-adder
P₁ = A, B₁
at the input produces an intermediary sum bit- call it Pn -which is expressed as
Next P₁ and C₁ are added using the X-OR gate inside the second half adder to produce the finalS₁ = P₁C₁ where P = A, B,₁,
n
sum bit and
becomes carry for the (n+1) thstage.
expressions.
and output carryCo= Pn.Cn-(A, B₁ )Cn which
Consider the case of both P₁ and C₂ being 1. The input carry C₁ has to be propagated
to the output only if Pn is 1. If Pn is 0, even if Cn is 1, the and gate in the second half-adder will
inhibit Cn. the carry out of the nth stage is 1 when either G₁=1 or Pn.Cn=1 or both G₁ and Pn.Cn
are equal to 1.
For the final sum and carry outputs of the nth stage, we get the following Boolean
S₁ = P, C, where P, = A, B₁,
n
Con=C+1=G+PC, where G₁ = A, B₁
Observe the recursive nature of the expression for the output carry
at the nth stage which becomes the input carry for the (n+1)st stage .it is possible to express the
output carry of a higher significant stage is the carry-out of the previous stage.
Based on these, the expression for the carry-outs of various full adders are as follows,
C₁= Go+ Po Co
C₂=G₁ + P₁
C₁ = G₁ + P₁
Go+ P₁ - Po Co
.
.
C₂=G₂ + P₂
C₂ = G₂ + P₂
G₁ + P₁₂ P₁ Go+ P₂P, Po. Co
2
.
.
2
1
C₁= G3 + P₂ C₂ = G3 + P3 · G₂ + P₂ P₂
The general expression for n stages
C₁=G₁-1+P-1C1 =G1 + P
G₁+ P3 P₂ P₁ Go + P₂ P₂ P₁. Po Co
designated as 0 through (n − 1) would be
G₁-2
n-2 G₁-3 +...+P
.Po. Co
Observe that the final output carry is expressed as a function of
the input variables in SOP form. Which is two level AND-OR or equivalent NAND-NAND
form. Observe that the full look-ahead scheme requires the use of OR gate with (n+1) inputs and
AND gates with number of inputs varying from 2 to (n+1).
+ P
n-1
.
5/BA
A₂
B3
A3
B₂
A₂
B₁
A₁
P
2009
P₁
GA
P₂
G₂
P₂
G₂
P₁
G₁
C₁
Look-ahead-carry
generator
CA
C₂
P₂
D
Logic diagram of a 4-bit look-ahead-carry adder.
2's complement Addition and Subtraction using Parallel Adders:
C5
SA
S3
Most modern computers use the 2's complement system to represent negative numbers
and to perform subtraction operations of signed numbers can be performed using only the
addition operation,if we use the 2's complement form to represent negative numbers.
The circuit shown can perform both addition and subtraction in the 2's complement. This
adder/subtractor circuit is controlled by the control signal ADD/SUB'. When the ADD/SUB'
level is HIGH, the circuit performs the addition of the numbers stored in registers A and B.
When the ADD/Sub' level is LOW, the circuit subtract the number in register B from the number
in register A. The operation is:
When ADD/SUB' is a 1:
1. AND gates 1,3,5 and 7 are enabled, allowing Bo,B₁,B₂and B3 to pass to the OR gates
9,10,11,12. AND gates 2,4,6 and 8 are disabled, blocking Bo',B₁,B₂', and B3' from
reaching the OR gates 9,10,11 and 12.
2. The two levels Bo to B3 pass through the OR gates to the 4-bit parallel adder, to be added
to the bits Ao to A3. The sum appears at the output Soto S3
3. Add/SUB' =1 causes no carry into the adder.
When ADD/SUB' is a 0:
1. AND gates 1,3,5 and 7 are disabled, allowing Bo, B₁, B2and B3 from reaching the OR gates
9,10,11,12. AND gates 2,4,6 and 8 are enabled, blocking Bo',B₁,B₂', and B3' from
reaching the OR gates.2. The two levels Bo' to B3' pass through the OR gates to the 4-bit parallel adder, to be
added to the bits Ao to A3. The Co is now 1.thus the number in register B is converted to
its 2's complement form.
3. The difference appears at the output Soto S3.
Adders/Subtractors used for adding and subtracting signed binary numbers. In computers, the
output is transferred into the register A (accumulator) so that the result of the addition or
subtraction always end up stored in the register A This is accomplished by applying a transfer
pulse to the CLK inputs of register A.
Transfer
pulse
B₂
A₂
CLK
7
B₂ B₂
D
11
A
CLK
Register B
B₂ B₁
5
10
D
B₁ B₂
74LS83
4-bit parallel adder
A₁
CLK
3
D
A
CLK
Bo
ADD/SUB
Co
S₁ S₂ S₁ So
Logic diagram of a parallel adder/subtractor using 2's complement system.
Serial Adder:
A serial adder is used to add binary numbers in serial form. The two binary numbers to be
added serially are stored in two shift registers A and B. Bits are added one pair at a time through
a single full adder (FA) circuit as shown. The carry out of the full-adder is transferred to a D flip-
flop. The output of this flip-flop is then used as the carry input for the next pair of significant
bits. The sum bit from the S output of the full-adder could be transferred to a third shift register.
By shifting the sum into A while the bits of A are shifted out, it is possible to use one register for
storing both augend and the sum bits. The serial input register B can be used to transfer a new
binary number while the addend bits are shifted out during the addition.
The operation of the serial adder is:
Initially register A holds the augend, register B holds the addend and the carry flip-flop is
cleared to 0. The outputs (SO) of A and B provide a pair of significant bits for the full-adder at x
and y. The shift control enables both registers and carry flip-flop, so, at the clock pulse both
registers are shifted once to the right, the sum bit from S enters the left most flip-flop of A, and
the output carry is transferred into flip-flop Q. The shift control enables the registers for a
number of clock pulses equal to the number of bits of the registers. For each succeeding clock
pulse a new sum bit is transferred to A, a new carry is transferred to Q, and both registers are
shifted once to the right. This process continues until the shift control is disabled. Thus the
addition is accomplished by passing each pair of bits together with the previous carry through a
single full adder circuit and transferring the sum, one bit at a time, into register A.Initially, register A and the carry flip-flop are cleared to 0 and then the first number is
added from B. While B is shifted through the full adder, a second number is transferred to it
through its serial input. The second number is then added to the content of register A while a
third number is transferred serially into register B. This can be repeated to form the addition of
two, three, or more numbers and accumulate their sum in register A.
Shift
control
CLK
Serial
input
SI
SI
Shift register A
Shift register B
SO
Difference between Serial and Parallel Adders:
SO
y
Z
Clear
O
Logic diagram of a serial adder.
FA
D
U
S
S
O
The parallel adder registers with parallel load, whereas the serial adder uses shift
registers. The number of full adder circuits in the parallel adder is equal to the number of bits in
the binary numbers, whereas the serial adder requires only one full adder circuit and a carry flip-
flop. Excluding the registers, the parallel adder is a combinational circuit, whereas the serial
adder is a sequential circuit. The sequential circuit in the serial adder consists of a full-adder and
a flip-flop that stores the output carry.
BCD Adder:
The BCD addition process:
1. Add the 4-bit BCD code groups for each decimal digit position using ordinary binary
addition.
2. For those positions where the sum is 9 or less, the sum is in proper BCD form and no
correction is needed.
3. When the sum of two digits is greater than 9, a correction of 0110 should be added
to that sum, to produce the proper BCD result. This will produce a carry to be added
to the next decimalposition.
A BCD adder circuit must be able to operate in accordance with the above steps. In other words,
the circuit must be able to do the following:
1. Add two 4-bit BCD code groups, usingstraight binaryaddition.2. Determine, if the sum of this addition is greater than 1101 (decimal 9); if it is, add
0110 (decimal 6) to this sum and generate a carry to the next decimalposition.
The first requirement is easily met by using a 4- bit binary parallel adder such as the 74LS83
IC .For example, if the two BCD code groups A3A2A1A0and B3B₂B₁Bo are applied to a 4-bit
parallel adder, the adder will output S4S3S2S1So, where S4 is actually C4, the carry out of the
MSB bits.
The sum outputs S4S3S2S1So can range anywhere from 00000 to 100109when both the
BCD code groups are 1001=9). The circuitry for a BCD adder must include the logic needed to
detect whenever the sum is greater than 01001, so that the correction can be added in. Those
cases, where the sum is greater than 1001 are listed as:
S₁
0
S3
0
0
S₂ S₁
0
1
0
1
1
0
0
0
0
1
So
0
1
1
1
Decimal number
10
11
12
13
14
15
16
17
18
Let us define a logic output X that will go HIGH only when the sum is greater than 01001
(i.e, for the cases table). If examine these cases ,see that X will be HIGH for either of the
following conditions:
1. Whenever S4=1(sum greater than15)
2. Whenever S3=1 and either S₂ or S₁ or both are 1 (sum 10 to 15)
This condition can be expressedas
X=S4+S3(S2+S1)
Whenever X=1, it is necessary to add the correction factor 0110 to the sum bits, and to
generate a carry. The circuit consists of three basic parts. The two BCD code groups A3A₂A1A0
and B3B₂B₁Bo are added together in the upper 4-bit adder, to produce the sum S4S3S2S1So. The
logic gates shown implement the expression for X. The lower 4-bit adder will add the correction
0110 to the sum bits, only when X=1, producing the final BCD sum output represented by
[32E¹0. The X is also the carry-out that is produced when the sum is greater than 01001.
When X=0, there is no carry and no addition of 0110. In such cases, E32E10= S3S2S1So.Two or more BCD adders can be connected in cascade when two or more digit decimal
numbers are to be added. The carry-out of the first BCD adder is connected as the carry-in of the
second BCD adder, the carry-out of the second BCD adder is connected as the carry-in of the
third BCD adder and so on.
EXCESS-3(XS-3) ADDER:
+0011
0100
(1)
Carry to the
next BCD adder
EX:
1
0100
0011
0111
SA
(4)
Correction logic
C₂
C₁
not
used
(b) 0111
+01 10
9 in Xs-3
1101
+1101
Σ₂
4-bit parallel adder (74LS83)
S₂ S₂ S₁ S. A3 A₂ A₁
To perform Excess-3 additions,
1. Add two xs-3 codegroups
2.
If carry=1, add 0011(3) to the sum of those two codegroups
If carry =0, subtract 0011(3) i.e., add 1101 (13 in decimal) to the sum of those two code
groups.
Ex: Add 9 and 5
1100
+1000
5 in xs-3
4-bit parallel adder (74LS83)
Σ₂₂ E
BCD sum
Logic diagram of a BCD adder using two 4-bit adders and a correction-detector circuit.
B₂₁ B₂ B₁ Bo
↓
there is a carry
add 3 to each group
14 in xs-3
4 in XS-3
3 in XS-3
AD
no carry
Subtract 3 (i.e. add 13)
Ignore carry 1 1010 7 in XS-3
(7)
BCD
code group
Co
Carry from
the lower position
adder
BCD
code group
Co-o
Comection
adder
Implementation of xs-3 adder using 4-bit binary adders is shown. The augend (A3
A2A1A0) and addend (B3B₂B₁Bo) in xs-3 are added using the 4-bit parallel adder. If the carry is a
1, then 0011(3) is added to the sum bits S3S2S1So of the upper adder in the lower 4-bit paralleladder. If the carry is a 0, then 1101(3) is added to the sum bits (This is equivalent to subtracting
0011(3) from the sum bits. The correct sum in xs-3 is obtained
Excess-3 (XS-3) Subtractor:
To perform Excess-3 subtraction,
1. Complement thesubtrahend
2. Add the complemented subtrahend to theminuend.
3.
If carry =1, result is positive. Add 3 and end around carry to the result. Ifcarry=0,
the result is negative. Subtract 3, i.e, and take the 1's complement of the result.
Ex:
00)
(1)
Perform 9-4
1100
+1000
0100
+0011
0111
1000
9 in xs-3
Complement of 4 n Xs-3
There is a carry
Add 0011(3)
The minuend and the 1's complement of the subtrahend in xs-3 are added in the upper 4-
bit parallel adder. If the carry-out from the upper adder is a 0, then 1101 is added to the sum bits
of the upper adder in the lower adder and the sum bits of the lower adder are complemented to
get the result. If the carry-out from the upper adder is a 1, then 3-0011 is added to the sum bits
of the lower adder and the sum bits of the lower adder give the result.
1001
1110
End around carry
Binary Multipliers:
In binary multiplication by the paper and pencil method, is modified somewhat in digital
machines because a binary adder can add only two binary numbers at a time.
In a binary multiplier, instead of adding all the partial products at the end, they are added two at
a time and their sum accumulated in a register (the accumulator register). In addition, when the
multiplier bit is a 0,0s are not written down and added because it does not affect the final result.
Instead, the multiplicand is shifted left by one bit.
1110
5 in xs-3
The multiplication of 1110 by 1001 using this processis
Multiplicand 1110
Multiplier
The LSB of the multiplier is a 1; write down the
multiplicand; shift the multiplicand one position to the left
(11 100)
The second multiplier bit is a 0; write down the previous
result 1110; shift the multiplicand to the left again (1 11 0+1110000
The fourth multiplier bit is a 1 write down the new
multiplicand add it to the first partial product to obtain the
final product.
1111110
This multiplication process can be performed by the serial multiplier circuit, which
multiplies two 4-bit numbers to produce an 8-bit product. The circuit consists of following
elements
X register: A 4-bit shift register that stores the multiplier it will shift right on the falling edge
of the clock. Note that Os are shifted in from the left.
===
B register: An 8-bit register that stores the multiplicand; it will shift left on the falling edge of
the clock. Note that Os are shifted in from the right.
A register: An 8-bit register, i.e, the accumulator that accumulates the partial products.
Adder: An 8-bit parallel adder that produces the sum of A and B registers. The adder outputs S7
through So are connected to the D inputs of the accumulator so that the sum can be transferred to
the accumulator only when a clock pulse gets through the AND gate.
The circuit operation can be described by going through each step in the multiplication of 1110
by 1001. The complete process requires 4 clock cycles.
1. Before the first clock pulse: Prior to the occurrence of the first clock pulse, the register A is
loaded with 00000000, the register B with the multiplicand 00001110, and the register X with
the multiplier 1001. Assume that each of these registers is loaded using its asynchronous
inputs(i.e., PRESET and CLEAR). The output of the adder will be the sum of A and B,i.e.,
00001110.
2. First Clock pulse:Since the LSB of the multiplier (Xo) is a 1, the first clock pulse gets through
the AND gate and its positive going transition transfers the sum outputs into the accumulator.
The subsequent negative going transition causes the X and B registers to shift right and left,
respectively. This produces a new sum of AandB.
3. Second Clock Pulse: The second bit of the original multiplier is now in Xo. Since this bit is a 0,
the second clock pulse is inhibited from reaching the accumulator. Thus, the sum outputs are
not transferred into the accumulator and the number in the accumulator does not change. The
negative going transition of the clock pulse will again shift the X and B registers. Again a new
sum is produced.
4. Third Clock Pulse:The third bit of the original multiplier is now in Xo;since this bit is a 0, the
third clock pulse is inhibited from reaching the accumulator. Thus, the sum outputs are not
transferred into the accumulator and the number in the accumulator does not change. The
negative going transition of the clock pulse will again shift the X and B registers. Again a new
sum is produced.
Code converters:
5. Fourth Clock Pulse: The last bit of the original multiplier is now in Xo, and since it is a 1, the
positive going transition of the fourth pulse transfers the sum into the accumulator. The
accumulator now holds the final product. The negative going transition of the clock pulse shifts
X and B again. Note that, X is now 0000, since all the multiplier bits have been shifted out.
The availability of a large variety of codes for the same discrete elements of
information results in the use of different codes by different digital systems. It is sometimes
necessary to use the output of one system as the input to another. A conversion circuit must beinserted between the two systems if each uses different codes for the same information. Thus a
code converter is a logic circuit whose inputs are bit patterns representing numbers (or
character) in one cod and whose outputs are the corresponding representation in a different
code. Code converters are usually multiple output circuits.
To convert from binary code A to binary code B, the input lines must supply the bit
combination of elements as specified by code A and the output lines must generate the
corresponding bit combination of code B. A combinational circuit performs this transformation
by means of logic gates.
For example, a binary -to-gray code converter has four binary input lines B4, B3,B2,B1 and four
gray code output lines G4,G3,G2,G₁. When the input is 0010, for instance, the output should be
0011 and so forth. To design a code converter, we use a code table treating it as a truth table to
express each output as a Boolean algebraic function of all the inputs.
In this example, of binary -to-gray code conversion, we can treat the binary to the
gray code table as four truth tables to derive expressions for G4, G3, G2, and G1. Each of these
four expressions would, in general, contain all the four input variables B4, B3,B2,and B1.
Thus,this code converter is actually equivalent to four logic circuits, one for each of the truth
tables.
The logic expression derived for the code converter can be simplified using the usual
techniques, including _don't cares if present. Even if the input is an unweighted code, the same
cell numbering method which we used earlier can be used, but the cell numbers --must
correspond to the input combinations as if they were an 8-4-2-1 weighted code. s
Design of a 4-bit binary to gray code converter:
Gạ = Em(8, 9, 10, 11, 12, 13, 14, 15) G,= B.
G₁ = Em(4, 5, 6, 7, 8, 9, 10, 11)
G₂ = Em(2, 3, 4, 5, 10, 11, 12, 13)
G₁ = Em(1, 2, 5, 6, 9, 10, 13, 14)
moooo0000-
1
1
B₂ B3 B₂ B₁
1
1
1
4-bit binary
1
1
OOOOTTITO00011
BOOTTOOT-OOTTO OFF
1
1
0
0
1
1
0
0
1
1
0
0
1
1
BOLOTOTOMOTOTO
0
0
1
0
1
0
1
0
1
1
0
1
0
0 1
1 0
1 1
G₁ G₂
0
0
0
0
1
1
1
1
ooooo
0
0
0
1
1
1
0
0
0
0
(a) Conversion table
0
0
0
0
1
1
1
1
1
4-bit Gray
G₂
1
1
1
0
0
1
1
1
1
0
0
0
0
1
1
1
1
0
0
G₁
0
1
1
0
0
1
1
0
0
1
1
0
0
1
1
0
G₁ = B₂B, + B₂B, =B₁ B₂
G₂ = B₂B₂ + B₂B₂ = B₂ © B₂
G₁ = B₂B₁ + B₂B, =B₂ B₁
BA
B₂-
B₂
B₁
(c) Logic diagram
4-bit binary-to-Gray code converter
G3
G₂GA
0
O
110000
4-bit Gray
G₂ G₂
O
0
1
0
0
0
O
G₂G₁
G.G
BB3
00
01
11
BB
10
G₁
O
1
1
B₂B₁
00
00
1
01
1
O
11
4
10
B₂B₁
12
8
00
01
11
10
00
00
01
1
1
1
1
1
1
1
5
13
BA
O
4
9
121
8
0
0
0
O
4
B
B
O
(a) Conversion table
B₁ = G4
B₂ = G₂G₂ + G₂G₂ = G₂ G₂
B₂ = G₁G₂G₂+G₂G₂G₂+G₂G₂G₂+G₂G₂G₂
11
1
01
1
1
1
01
1
3
7
1
15
1
11
S
13
B₁ = G₁
K-map for B₂
9
G₁ - B4
5
Design of a 4-bit gray to Binary code converter:
13
4-bit binary
B₂ B₂
0
0
O
0
0
1
0
1
B₂
G₂ - B₂
K-map for G₂
11
1
1
10
for G
1
1
1
15
11
14
10
3
7
11
10
1
11
10
1
= G₂(G₂ G₂) + G₂(G₂ G₂) = G₂ G₂ G₂ = B3 G₂
B₁ = G₂G₂G₂G₁ G₂G₂G₂G₁ + G₂G₂G₂G₁ + + ĢG¸Ñ‚Ñ‚ + GG₂G₂G₁
1
B₁
0
1
10
0
1
14
10
B₂ = Σ m(12, 13, 15, 14, 10, 11, 9, 8) = Σ m(8, 9, 10, 11, 12, 13, 14, 15)
B₂ = Σ m( 6, 7, 5, 4, 10, 11, 9, 8) = Σ m(4, 5, 6, 7, 8, 9, 10, 11)
3
B₂ = Σ m(3, 2, 5, 4, 15, 14, 9, 8) = Σ m(2, 3, 4, 5, 8, 9, 14, 15)
B₁ = Σ m(1, 2, 7, 4, 13, 14, 11, 8) = Σ m(1, 2, 4, 7, 8, 11, 13, 14)
00
G₂G₁
G₂G
01
11
= Ģ₂Ģ₂(G₂ G₂) +G₂G₂(G₂ ÐG₁) + G₂G₂(G₂ ©G₁ ) +G₂G₂(G₂ ©G₁)
= (G₂G₁)(G₂ G₂) + (G₂ Ð G₁ )G₂ G₂)
4
=G₂ G₂ G₂ G₁
G₂
10
BAB
G₂
00
B₂B
1
B₂B₁
1
00
01
11
0
10
B₂B,
4
12
00
al
01
11
10
00
1
(b) K-maps
4-bit binary-to-Gray code converter.
00
01
1
12
5
0
13
12
8
4
D
(c) Logic diagram
1
11
1
01
3
7
1
01
1
1
15
1
+G₂G₂G₂G₁ +G₂G₂G₂G‚±G¸Ñ‚G₂G₁
11
1
B₂ = G₁ G₂
K-map for B₂
5
13
1
G3 = B, ⒸB3
K-map for Ga
11
D
15
9
1
G₁- B₂B,
K-map for G₁
11
BA
1
B₂
B₂
10
B,
31
F
14
15
10
7
15
11
10
1
10
1
1
1
1
10B₁
100000000,
8421 code
B₂
0000
B₁
G₁G3
00
10101
B₂B,
00
01
B₂B₁
11
10
01
B₂B,
11
(a) Conversion table
10
01
B₂B₁
11
X₂
O
10
00
X
1
00 1
00
1
00
|-|
X
Design of a 4-bit BCD to XS-3 code converter:
1
0
4
12
8
1
0
1
4
12
0
XS-3 code
X3 X₂
O
1
8
4
12
8
01
4
1
X
1
1
01
x
5
13
B₂=G₁ G₂ G₂
K-map for B₂
9
01
1
1
5
13
1
9
5
13
COTTO
9
11
1
X
X
X₂ =B₁ + B₂B₂+ B₂B₁
K-map for X₂
1
4-bit BCD-to-XS-3 code converter
1
X
3
X
7
11
X₂
15
1
1
7
15
3
11
7
15
11
X₂ =B₂B₁ + B₂B₁
K-map for X₂
11 10
10
1
X
X
X
2
6
14
10
10
6
1
14
1
10
6
14
10
G₁G3
00
01
(b) K-maps
4-bit Gray-to-binary code converter.
11
10
B₂B₁
B₂B₂
00
00
11
10
01 1
B₂B₁
B₂B
1
10
1
The minimal expressions are
X4 =B₁ + B₂B₂+ B₂B,
X₂ = B₂B₂B₁ + B₂B₁ + B₂B₂
X₂ = B₂B₁ + B₂B₁
X, = B₂
x
00 1
12
01 1
11 X
0
00
1
8
00 01
0
1
(b) Minimal expressions
12
8
01
1
1
X₂ = Σ m(5, 6, 7, 8, 9) + d(10, 11, 12, 13, 14, 15)
X₂ = Σm(1, 2, 3, 4, 9) + d(10, 11, 12, 13, 14, 15)
X₂ = Σ m(0, 3, 4, 7, 8) + d(10, 11, 12, 13, 14, 15)
X, = m(0, 2, 4, 6, 8) + d(10, 11, 12, 13, 14, 15)
4
0
1
12
8
B₁ = G₂ G₂ G₂ G₁
K-map for B,
X
13
1
01
X
5
5
13
9
9
5
13
11
9
11
1
X
1
1
X
X
X
(c) K-maps
4-bit BCD-to-XS-3 code converter.
15
11
11
15
3
11
7
X₂ = B₂B₂B₁ + B₂B₁ + B₂B₂
K-map for X₂
3
7
3
7
15
11
10
X₁ =B₁
K-map for X,
1
X
10
X
1
1
1
1
X
X
14
10
1
2
6
14
10
10
6
6
14
10Design of a BCD to gray code converter:
Docimal
number
Decimal
number
B₂
0
1
2
3
4
5
BCD code
B₂
B₁
0
O
O
O
6
7
8
B.B
B.B
Oo
01
O
11
10
8.0
(a) BCD-to-Gray code conversion table
B.Bo
00
O
O
1
01
O
11
10
00
Bo
0
1
O
(a) Truth table
4
5211 code
A B C D
01
000 0
000 1
0 0 1 1
1
O 1 0
0 1 1 1
1
0 0 0
1
1
1 1
1 0
1
1 1
(a) Truth table
4-bit Gray codo Output
A B C D
f
0
10
0
0 1 0
1 00
01
S
G₂-B,
G3
T
11
Output
f
Gray code
G₁
G₂
11
1
0
1
0
G₁ - B₂B, + B₂B, B₂B,
1
0
1
0
1
0
O
O
O
O
1
AB
10
10
OD
01
11
10
10
O
O
1
1
O
O
BCD-to-Gray code converter.
CD
AB
01
11
10
1
1
00 1
00
Go
0
X
0
4
12
8
01
X
B.B
1
01
11
5
ECE.
13
15
1
9
11
fmin BC + BD + ACD
(b) K-map
5
B,B
13
00
9
01
B₂B2
Design of a SOP circuit to Detect the Decimal numbers 5 through 12 in a 4-bit gray code
Input:
10
1
1
00
01
11 IX
B,Bo
11
10
x
B3
B₂
Go - B, Bo + B₁. Bo - B, Bo
K-maps for a BCD-to-Gray code converter.
11
B₁
Bo
B
(C) NAND logic
Truth table, K-map and logic diagram for the SOP circuit.
7
15
00
11
1
1
80
Design of a SOP circuit to detect the decimal numbers 0,2,4,6,8 in a 4-bit 5211 BCD code
input:
10
14
6
O
10
12
x
1
6
1
(b) Logic diagram
01
6
1
14
X
10
1
01
13
6
0 0 0 0 200
11
1
G₂ =B₂+ B₂
X
X
Ā
D
11
D
G₁
F
Go
10
1
X
10
TO
G3
G₂
2°
B
fmin = AD + AC + CD
(b) K-map
Truth table, K-map and logic diagram for the SOP circuit.
(c) Logic diagramDesign of a Combinational circuit to produce the 2's complement of a 4-bit binary number:
Comparators:
A
0
0
AB
0
0
0
0
0
0
1
1
1
1
1
1
1
1
CD
00
01
B
10
OOOOTTTTOOOO
0
Input
0
0
0
1
1
1
0
0
0
1
1
1
1 1
00
1
1
N
X-
A
C D
|
B
8011OOT-OOT-OOT-
12
01
1
X
1
5
0
13
1
▬▬
0
1
0
1
0
1
0
1
0
1
0
0
1
(a) Conversion table
Conversion table and K-maps for the circuit
3
0123456789
6
(a) Seven-segment display
11
1
1
XX
x
15
E
0 0
1
1
1
1
1
1
1
1
X
Output
F G
1min = B+ CD + CD
(b) K-map
10,
1
0
0
1 0
0
OOTTY
1
1
1-bit
comparator
81100T TOOTLOOTTO
1.
H
0
1
1
1 0
-110
0 1
1 0
0 0
bro-ororo,
1 0
1 0 0
0 0 1 1
0
C
D
0
0 1
EQUALITY = (A, O B₂)(A₂ O B₂)(A, OB₁)(A, OB₂)
:D
(c) Logic diagram
L
Block diagram of a 1-bit comparator.The logic for a 1-bit magnitude comparator: Let the 1-bit numbers be A = A and B = Bo.
If A = 1 and Bo= 0, then A > B.
Therefore,
If A = 0 and B₁ = 1, then A <B.
Therefore,
A<B: L = Ã₂B₁
If A and B coincide, i.e. A = B = 0 or if A, B = 1, then A = B.
Therefore,
0
A = B: E=A₁ OBO
A₂
Bo
O
1
O
1
(a) Truth table
L
O
1
O
O
1. Magnitude Comparator:
E
1
O
O
1
A₁
B₁
G
O
0
1
O
Ao
Bo
A>B: G=A₂B₁
Bo
1- bit Magnitude Comparator:
The logic for a 2-bit magnitude comparator: Let the two 2-bit numbers be A = A₁ A₁ and B=B₁ B₁.
1. If A₁ = 1 and B₁ = 0, then A > B or
2. If A, and B, coincide and A₁ = 1 and B = 0, then A > B. So the logic expression for A > B is
A>B: G=A,B₁ + (A, O B₁)A,B
B₁
(b) Logic diagram
1. If A₁ = 0 and B₁ = 1, then A < B or
2. If A, and B, coincide and A₁ = 0 and B₁ =1, then A< B. So the expression for A< B is
Ã₂
1-bit comparator.
A<B:L=Ā, B₁ + (A, OB,)Ã B₁
If A, and B, coincide and if A, and B, coincide then A= B. So the expression for A = B is
A=B: E=(A, OB,)(A, OB.)
Ã₁
A <B(L)
A > B
A = B(E)
A <B
A> B(G)
Logic diagram of a 2-bit magnitude comparator.4-Bit MagnitudeComparator:
The logic for a 4-bit magnitude comparator: Let the two 4-bit numbers be A = A₂A₂A₁A and
B = B₂B₂B₁B0-
1. If A₂ = 1 and B3 = 0, then A > B. Or
2. If A3 and B3 coincide, and if A₂ = 1 and B₂ = 0, then A > B. Or
3. If A and B3 coincide, and if A, and B₂ coincide, and if A₁ = 1 and B₁ = 0, then A > B. Or
4. If A, and B₂ coincide, and if A, and B₂ coincide, and if A, and B, coincide, and if A = 1
and Bo= 0, then A > B.
From these statements, we see that the logic expression for A > B can be written as
(A > B) = A₂B3 + (A3 © B₂)A₂B₂ + (A₂ O B₂)(A₂ O B₂)A₁B₁
+ (A₂ O B₂)(A₂ O B₂)(A, O B₁)A, B₁
Similarly, the logic expression for A< B can be written as
A<B=A₂B₂+ (A, O B₂)Ã₂B₂+ (A₂ O B₂)(A₂ O B₂)A,B,
+ (A, OB₂)(A₂ O B₂)(A, OB₁)A₂B₁
If A, and B, coincide and if A₂ and B₂ coincide and if A, and B, coincide and if A, and Bo
coincide, then A = B.
So the expression for A = B can be written as
A₂
B₁
A₂
B₂
A₁
B₁
Ao
Bo
(A = B) = (A3 O B₂)(A₂ OB₂)(A, OB₁)(A, O B₁)
B₂-
B₁
Do
Đ
B3
B₂
B₁
B₂
A₂
A₂
A₁
A₂
A₂
A₂
Ā₁
Ā₂
A>B
A=B
-A<BIC Comparator:
ENCODERS:
LSBs
A₂
A₁
+Vcc
dddddddd
Octal to Binary
Encoder:
Octal digits
A₂
A3
5-bit
number X
O
BB
5-bit
number
4567
Bo
B₁
B₂
B3
Ao
A₁
A₂
A3
O
Bo
B₁
B₂
B3
***** ****
(A <B)IN
(A= B)IN
(A>B)IN
(A= B) OUT
(A > B)IN
(A <B) IN
(A = B) IN
A₁
GND
(a) Truth table
(A <B)OUT
(A = B) OUT
(A > B) OUT
B₂
A₂
7485
M inputs
only one
HIGH at
a time
Binary
Az A₁ A₂
O
O
O
A3
Az
A,
Ao
A> B
1
B
B₂
B₁
Bo
A<B
A=B
2345
AM-2
AM-1
6
7
8
7485
(a) Pin diagram of 7485
MSBS
7485
A> BO
Vcc
A₂
B3
(A > B) OUT
12(A< B) OUT
A<BO
A=Bb
16
15
14
13
(b) Cascading of two 7485s
Pin diagram and cascading of 7485 4-bit comparators.
ENCOD
11
Bo
10 Ao
9
B₁
A₁-A₂
As-A₁
A₂
A₂
(A <B)IN
(A = B) IN
(A > B) IN
B₂
B₁
B₂
B3
As
A
BA
Bs
Be
B,
Not used
(A <B) OUT
(A = B) OUT
(A > B) OUT
7485
Octal inputs
D₁ D₂ D₂ D₁ Ds De D₂
ON 2
OON
Block diagram of encoder.
Use of 7485 as a 5-bit comparator.
(b) Logic diagram
>Y
Octal-to-binary encoder.
(A <B)
(A = B)
(A > B)
X=Y Outputs
X<YJ
N-bit
output
code
Az
A₁
A₂
Binary
outputsDecimal to BCD Encoder:
Decimal
inputs
Tristate bus system:
4 DEC/BCD
(a) Logic symbol
A
BCD
outputs
Decimal inputs
D₁ D₂ D₂ D₂ D₂ D D7 D₂ D₂
Decimal inputs
(c) Logic diagram
Decimal-to-BCD encoder.
In digital electronicsthree-state, tri-state, or 3-statelogic allows an output port to assume a high
impedance state in addition to the 0 and 1 logic levels, effectively removing the output from the
circuit.
B
This allows multiple circuits to share the same output line or lines (such as a bus which cannot
listen to more than one device at a time).
A tristate buffer can be thought of as a switch. If B is
on, the switch is closed. If B is off, the switch is open.
Three-state outputs are implemented in many registers, bus drivers, and flip-flops in the 7400 and
4000 series as well as in other types, but also internally in many integrated circuits. Other typical
uses are internal and external buses in microprocessors, computer memory, and peripherals. Many
devices are controlled by an active-low input called OE (Output Enable) which dictates whether
the outputs should be held in a high-impedance state or drive their respective loads (to either 0- or 1-
level).
9 b
5
(b) Truth table
INPUT
A
<OTX
Binary
A3 A₂ A₁ A₂
0
1
0
1
0
1
0
1
0
1
0
BCD
outputs
B
1
OUTPUT
C
0
1
O Z (high impedance)The Basic Latch
Basic latch is a feedback connection of two NOR gates or two NAND gates
O It can store one bit of information
The Gated Latch
It can be set to 1 using the S input and reset to 0 using the R input
M
O Gated latch is a basic latch that includes input gating and a control signal
The latch retains its existing state when the control input is equal to 0
Its state may be changed when the control signal is equal to 1. In our discussion we referred to
the control input as the clock
We consider two types of gated latches:
■
Gated SR latch uses the S and R inputs to set the latch to 1 or reset it to 0,
respectively.
Gated S/R Latch
Gated D latch uses the D input to force the latch into a state that has the samelogic
value as the D input.
BQ
UNIT-IV
SEQUENTIAL CIRCUITS
Cik
R
000
10
(a) Circuit
A
(c) Timing diagram
S
CTE
(d) Graphical symbol
Cik SR
O
1
1
t
1
K K
O 0
0 1
1
1
Q(r) (no change)
Q) (no change)
1
(b) Characteristic tabloGated D Latch
Clk
D
D
(Data)
CIK
CIK D
0
1
1
0
1
Flip-Flops
Setup and Hold Times
(b) Characteristic table.
Q(t+1)
Q(t)
0
Hold Time th
S
R
(a) Circuit
D Q
(d) Timing diagram
Clk Q
(c) Graphical symbol
14
Setup Time tsu
The minimum time that the input signal must be stable prior to the edge of the clock signal.
Time
The minimum time that the input signal must be stable after the edge of the clock signal.
A flip-flop is a storage element based on the gated latch principle
It can have its output state changed only on the edge of the controlling clocksignal
O We consider two types:D
Clock
Clock
D
Qm
Q = Q₂
Clock
O Edge-triggered flip-flop is affected only by the input values present when theactive
edge of the clock occurs
O Master-slave flip-flop is built with two gatedlatches
The master stage is active during half of the clock cycle, and the slave stage is active
during the other half.
O The output value of the flip-flop changes on the edge of the clock that activates the
transfer into the slave stage.
Master-Slave D Flip-Flop
Master
D
Cik
aten
(a) Circuit
Graphical symbol
(b) Timing diagram
D
(c) Graphical symbol
A Positive-Edge-Triggered D Flip-Flop
D
Q
Q
Slave
D Q
Cik Q
a
ā
Q₂
Q
ŌMaster-Slave D Flip-Flop with Clear and Preset
Preset-
Clear
T Flip-Flop
Clock
T
Q
T
Clock
D
V
C
0
10
(a) Circuit
J
K
Clock
D
(d) Timing diagram
ā
T Q
J K
Ilot+1).
Q(1)
Q(1)
(b) Characteristic table (c) Graphical symbol
00
01
10
11
Q (t+1)
a 10
Q (t)
0
Q
(a) Circuit
D
1
Q (t)
(b) Characteristic table (c) Graphical symbol
J
Q
#
K
10Excitation Tables
Previous State -> Present State
0-0
0 -> 1
1 -> 0
1 -> 1
Previous State -> Present State
0-> 0
0 - 1
1 -> 0
1 -> 1
Previous State -
->Present State
0-> 0
1
1 -> O
1 -> 1
0
->
Previous State -> Present State
0-0
0-
→> 1
1 -> O
1 -> 1
S
0
1
0
X
J
0
1
X
X
D
0
1
0
1
T
0
1
1
0
R
X
0
1
K
X
X
1
0Conversions of flip-flops
Example: Use JK-FF to realize D-FF
1) Start transition table for D-FF
2) Create K-maps to express J and K as functions of inputs (D, Q)
3) Fill in K-maps with appropriate values for J and K
to cause the same state transition as in the D-FF transition table
D Q
0
0
0
1
1
0
1
1
State-Table
DUL17000
000
e.g.
when D=Q=0, then Q*=0
the same transition Q-->Q+
is realize with J=0, K=X
ܘܘܝ ܝ ܘܘܝܝ
10101010
Example: Implement JK-FF using a D-FF
J K Q Q+
D
T
1 0
0
JK
1
1
00 01
000
1 0
JK
0 X
X 1
X
X 0
01001110
d= jQ + Kq
01110100
11 10
1 1
0 1
1110
80100
1101000
Q Q+
K-
JK
1
D
0
1
0 0
0
0
0
X
t= jQ + kq
Dy
00 01
0
RS
X 0
0
1
1 0
0 X
1
1
X
J=D
CIK
-
J
11 10
1
1
CIK
0
T
70-XX
J K T
C
1
0 X 0
XXX-0
OOX X
1
1 0
KED
D
C
T-FF
DFF
1 1
D
0
1
0
0 1
0
O
OSequential Circuit Design
●
●
●
Steps in the design process for sequential circuits
State Diagrams and State Tables
Examples
●
Steps in Design of a Sequential Circuit
1. Specification - A description of the sequential circuit. Should include a detailing of
the inputs, the outputs, and the operation. Possibly assumes that you have knowledge of
digital system basics.
2. Formulation: Generate a state diagram and/or a state table from the statement of the
problem.
3. State Assignment: From a state table assign binary codes to thestates.
4. Flip-flop Input Equation Generation: Select the type of flip-flop for the circuit and generate
the needed input for the required state transitions
5. Output Equation Generation: Derive output logic equations for generation of the
output from the inputs and current state.
●
O
In
O
Clock
O
O
O
O
Registers and Counters
O
An n-bit register is a cascade of n flip-flops and can store an n-bit binary data
A counter can count occurrences of events and can generate timing intervals for control purposes
A Simple Shift Register
O
6. Optimization: Optimize the input and output equations. Today, CAD systems are
typically used for this in real systems.
7. Technology Mapping: Generate a logic diagram of the circuit using ANDS, ORS,
Inverters, and F/Fs.
8. Verification: Use a HDL to verify the design
ܩ
D
t6
t7
t₁ 0
t2
1
t3
1
1
0
0
0
(a) Circuit
In Q₁
1 0
1
0
1
1
1
0
0
0
0
1
0
1
1
1
0
D Q
Q4 = Out
O
0
0 0
0 0
1 0
0
1
1
0
1
1
1
1
Q3
(b) A sample sequence
D
OutParallel-Access Shift Register
Şerial
input
Counters
●
●
●
●
D
Shift/Load
Q3
Q
Q2
D Q
O
Parallel output
D
Parallel input
Q₁
ARR
D
Counters are a specific type of sequential circuit.
Like registers, the state, or the flip-flop values themselves, serves as the "output."
The output value increases by one on each clock cycle.
After the largest value, the output "wraps around" back to 0.
Using two bits, we'd get something like this:
Qo
O
ClockPresent State
A
0
1
1
Benefits of counters
B
happened.
0
1
Next State
A
0
1
1
B
1
0
Counters can act as simple clocks to keep track of "time." •
You may need to record how many times something has
How many bits have been sent or received?
How many steps have been performed in some computation?
All processors contain a program counter, or PC.
Programs consist of a list of instructions that are to be executed one after another (for the
most part).
The PC keeps track of the instruction currently being executed.
The PC increments once on each clock cycle, and the next program instruction is then
executed.A Three-Bit Up-Counter
Q₁ is connected to clk, Q2 and Q3 are clocked by Q' of the preceding stage (hence called
asynchronous or ripple counter
Clock
Q₂
Count 0
Clock
Qo
A Three-Bit Down-Counter
Q1
Clock
Q₂
1 2 3
T Q
100
(a) Circuit
Clock
Count 0 7
6
(b) Timing diagram
5
4 5 6 7 0
(a) Circuit
4
3
(b) Timing diagram
T
2
Q2
1
0Shift registers:
In digital circuits, a shift register is a cascade of flip-flops sharing the same clock, in
which the output of each flip-flop is connected to the "data" input of the next flip-flop in the
chain, resulting in a circuit that shifts by one position the "bit array" stored in it, shifting in the
data present at its input and shifting out the last bit in the array, at each transition of the clock
input. More generally, a shift register may be multidimensional, such that its "data in" and stage
outputs are themselves bit arrays: this is implemented simply by running several shift registers of
the same bit-length in parallel.
Shift registers can have both parallel and serial inputs and outputs. These are often configured
as serial-in, parallel-out (SIPO) or as parallel-in, serial-out (PISO). There are also types that
have both serial and parallel input and types with serial and parallel output. There are also bi-
directional shift registers which allow shifting in both directions: L→R or R→L. The serial
input and last output of a shift register can also be connected to create a circular shift register
Shift registers are a type of logic circuits closely related to counters. They are basically for the
storage and transfer of digital data.
Buffer register:
The buffer register is the simple set of registers. It is simply stores the binary word. The buffer
may be controlled buffer. Most of the buffer registers used D Flip-flops.
Clock
X1
FFA
X2
X3
of Lo LD
FFB
FFC
3337
CLK
CLK
CLK
X4
When the positive clock edge arrives, the stored word becomes:
Q4Q3Q2Q1=X4X3X₂X1
FFD
Figure: logic diagram of 4-bit buffer register
The figure shows 4-bit buffer register. The binary word to be stored is applied to the data
terminals. On the application of clock pulse, the output word becomes the same as the word
applied at the terminals. i.e., the input word is loaded into the register by the application of clock
pulse.
Q=X
When load is low, the X bits cannot reach the FF's.
CLK
Q=X
Controlled buffer register:
If goes LOW, all the FFs are RESET and the output becomes, Q=0000.
When is HIGH, the register is ready for action. LOAD is the control input. When
LOAD is HIGH, the data bits X can reach the D inputs of FF's.
Q4Q3Q2Q1=X4X3X2X1Data transmission in shift registers:
data in
clock
data in
clock
mode
data in
clock
data in
clock
stage A
D
stage B
Serial-in, serial-out shift register with 4-stages
stage A
stage A
DB
DA
stage B
stage A
stage B
stage C
QB
QB
QA
Parallel-in, parallel-out shift register with 4-stages
DB
Dc
stage B
stage C
Qc
stage C
Qc
Serial-in, parallel-out shift register with 4-stages
stage D
Dc
DD
stage C
stage D
stage D
QD
DD
stage D
data out
Parallel-in, serial-out shift register with 4-stages
data out
data out
data out
A number of ff's connected together such that data may be shifted into and shifted out of them is
called shift register. data may be shifted into or out of the register in serial form or in parallel
form. There are four basic types of shift registers.
1. Serial in, serial out, shift right, shift registers
2. Serial in, serial out, shift left, shift registers
3. Parallel in, serial out shift registers
4. Parallel in, parallel out shift registersSerial IN, serial OUT, shift right, shift left register:
The logic diagram of 4-bit serial in serial out, right shift register with four stages. The register
can store four bits of data. Serial data is applied at the input D of the first FF. the Q output of the
first FF is connected to the D input of another FF. the data is outputted from the Q terminal of
the last FF.
1
1
omomo
0
0 0
1
D Q
D Q
-3307
FFB
FFC
CLK
CLK
Serial
Data in FFA
Clock
D Q
Serial
Data in
Serial-in, parallel-out, shift register:
Clear
Clock
D
CLK
When serial data is transferred into a register, each new bit is clocked into the first FF at the
positive going edge of each clock pulse. The bit that was previously stored by the first FF is
transferred to the second FF. the bit that was stored by the Second FF is transferred to the third
FF.
FFA
CLK
CLR
QA
D
FFB
CLK
CLR
QB
D
FFC
CLK
D
CLR
FFD
QC
CLK
D
FFD
CLK
1
CLR
Serial
Data out
Data out
In this type of register, the data bits are entered into the register serially, but the data stored in
the register is shifted out in parallel form.
Once the data bits are stored, each bit appears on its respective output line and all bits are
available simultaneously, rather than on a bit-by-bit basis with the serial output. The serial-in,
parallel out, shift register can be used as serial-in, serial out, shift register if the output is taken
from the Q terminal of the last FF.Parallel-in, serial-out, shift register:
Wewn
For a parallel-in, serial out, shift register, the data bits are entered simultaneously into their
respective stages on parallel lines, rather than on a bit-by-bit basis on one line as with serial data
bits are transferred out of the register serially. On a bit-by-bit basis over a single line.
There are four data lines A,B,C,D through which the data is entered into the register in
parallel form. The signal shift/ load allows the data to be entered in parallel form into the register
and the data is shifted out serially from terminalQ4
Parallel-in, parallel-out, shift register
r
Clock
Parallel outputs
QA
QB
D
FFA
FFB
parn
CLK
CLK
PB
Parallel inputs
PA
PC
FFC
CLK
QC
PD
D
FFD
CLK
In a parallel-in, parallel-out shift register, the data is entered into the register in parallel form,
and also the data is taken out of the register in parallel form. Data is applied to the D input
terminals of the FF's. When a clock pulse is applied, at the positive going edge of the pulse, the
D inputs are shifted into the Q outputs of the FFs. The register now stores the data. The stored
data is available instantaneously for shifting out in parallel form.Bidirectional shift register:
A bidirectional shift register is one which the data bits can be shifted from left to right
or from right to left. A fig shows the logic diagram of a 4-bit serial-in, serial out, bidirectional
shift register. Right/left is the mode signal, when right /left is a 1, the logic circuit works as a
shift-register.the bidirectional operation is achieved by using the mode signal and two NAND
gates and one OR gate for each stage.
A HIGH on the right/left control input enables the AND gates G1, G2, G3 and G4 and
disables the AND gates G5,G6,G7 and G8, and the state of Q output of each FF is passed
through the gate to the D input of the following FF. when a clock pulse occurs, the data bits are
then effectively shifted one place to the right. A LOW on the right/left control inputs enables the
AND gates G5, G6, G7 and G8 and disables the And gates G1, G2, G3 and G4 and the Q output
of each FF is passed to the D input of the preceding FF. when a clock pulse occurs, the data bits
are then effectively shifted one place to the left. Hence, the circuit works as a bidirectional shift
register
CLEAR
CLK
Input data
MSB
D B
Universal shift register:
C.R
Figure: logic diagram of a 4-bit bidirectional shift register
OR
LEFT/RIGHT
Output data
A register is capable of shifting in one direction only is a unidirectional shift register. One that
can shift both directions is a bidirectional shift register. If the register has both shifts and parallel
load capabilities, it is referred to as a universal shift registers. Universal shift register is a
bidirectional register, whose input can be either in serial form or in parallel form and whose
output also can be in serial form or I parallel form.
The most general shift register has the following capabilities.
1. A clear control to clear the register to 0
2. A clock input to synchronize the operations
3. A shift-right control to enable the shift-right operation and serial input and output lines
associated with the shift-right4. A shift-left control to enable the shift-left operation and serial input and output lines
associated with the shift-left
5.
A parallel loads control to enable a parallel transfer and the n input lines associated with
the parallel transfer
6. N parallel output lines
7. A control state that leaves the information in the register unchanged in the presence of
the clock.
A universal shift register can be realized using multiplexers. The below fig shows the logic
diagram of a 4-bit universal shift register that has all capabilities. It consists of 4 D flip-flops and
four multiplexers. The four multiplexers have two common selection inputs s1 and s0. Input 0 in
each multiplexer is selected when S1S0-00, input 1 is selected when S1S0-01 and input 2 is
selected when S1S0=10 and input 4 is selected when S1S0=11. The selection inputs control the
mode of operation of the register according to the functions entries. When S1S0=0, the present
value of the register is applied to the D inputs of flip-flops. The condition forms a path from the
output of each flip-flop into the input of the same flip-flop. The next clock edge transfers into
each flip-flop the binary value it held previously, and no change of state occurs. When S1S0-01,
terminal 1 of the multiplexer inputs have a path to the D inputs of the flip-flop. This causes a
shift-right operation, with serial input transferred into flip-flopA4. When S1S0=10, a shift left
operation results with the other serial input going into flip-flop A1. Finally when S1S0=11, the
binary information on the parallel input lines is transferred into the register simultaneously
during the next clock cycle
Clear
CLK
S₁
So
Serial
input for
shift-right
A4
4x1
MUX
3 2 10
14
Parallel outputs
13
A3
4x1
MUX
3 2 1 0
A₂
4x1
MUX
3 2 10
12
4x1
MUX
3 2 1
4₁
A₁
4-bit universal shift register
Figure: logic diagram 4-bit universal shift register
Serial
input for
shift-leftFunction table for theregister
Counters:
●
●
Counter is a device which stores (and sometimes displays) the number of times
particular event or process has occurred, often in relationship to a clock signal. A Digital counter
is a set of flip flops whose state change in response to pulses applied at the input to the counter.
Counters may be asynchronous counters or synchronous counters. Asynchronous counters are
also called ripple counters
●
In electronics counters can be implemented quite easily using register-type circuits such as
the flip-flops and a wide variety of classifications exist:
●
mode control
SO S1 register operation
●
0
0
1
1
●
0
1
0
1 Parallel load
No change
Shift Right
Shift left
Asynchronous (ripple) counter - changing state bits are used as clocks to subsequent state
flip-flops
Synchronous counter - all state bits change under control of a singleclock
Decade counter - counts through ten states per stage
Up/down counter - counts both up and down, under command of a control input
Ring counter - formed by a shift register with feedback connection in a ring
Johnson counter - a twisted ring counter
Cascaded counter
Modulus counter.
Each is useful for different applications. Usually, counter circuits are digital in nature, and count
in natural binary Many types of counter circuits are available as digital building blocks, for
example a number of chips in the 4000 series implement different counters.
Occasionally there are advantages to using a counting sequence other than the natural binary
sequence such as the binary coded decimal counter, a linear feed-back shift register counter, or
a gray-code counter.
Counters are useful for digital clocks and timers, and in oven timers, VCR clocks, etc.Asynchronous counters:
An asynchronous (ripple) counter is a single JK-type flip-flop, with its J (data) input fed
from its own inverted output. This circuit can store one bit, and hence can count from zero to one
before it overflows (starts over from 0). This counter will increment once for every clock cycle
and takes two clock cycles to overflow, so every cycle it will alternate between a transition from
0 to 1 and a transition from 1 to 0. Notice that this creates a new clock with a 50% duty cycle at
exactly half the frequency of the input clock. If this output is then used as the clock signal for a
similarly arranged D flip-flop (remembering to invert the output to the input), one will get
another 1 bit counter that counts half as fast. Putting them together yields a two-bit counter:
Two-bit ripple up-counter using negative edge triggered flip flop:
Two bit ripple counter used two flip-flops. There are four possible states from 2
counting I.e. 00, 01, 10 and 11.
The counter is initially assumed to be at a state 00 where the outputs of the tow flip-flops
are noted as Q1Qo. Where forms the MSB and Qo forms the LSB.
For the negative edge of the first clock pulse, output of the first flip-flop FF₁ toggles its
state. Thus Q₁ remains at 0 and Qo toggles to 1 and the counter state are now read as 01.
During the next negative edge of the input clock pulse FF1 toggles and Qo= 0. The output
Q0 being a clock signal for the second flip-flop FF2 and the present transition acts as a negative
edge for FF2 thus toggles its state Q₁ = 1. The counter state is now read as 10.
For the next negative edge of the input clock to FF₁ output Q0 toggles to 1. But this
transition from 0 to 1 being a positive edge for FF2 output Q₁ remains at 1. The counter state is
now read as 11.
For the next negative edge of the input clock, Qo toggles to 0. This transition from 1 to 0
acts as a negative edge clock for FF2 and its output Qi toggles to 0. Thus the starting state 00 is
attained. Figure shown below
CLK
HIGH
J
SET
CUR
O
bit up-
HIGH
J
SET
K CAR
Q₁CLK D
Q₁
0
Q1' 0
CLK D
1
0
1
0
Q₂ 0
Qo
Q₁
À
Two-bit ripple down-counter using negative edge triggered flip flop:
HIGH-
CLOCK-
1
J Q
CLK
K
N
பர்
0 1 2 3
2
10
3
Qo
J
1
CLK
K
5
IC
5
6
4567
8
0
A 2-bit down-counter counts in the order 0,3,2,1,0,1.......,i.e, 00,11,10,01,00,11 .....,etc. the
above fig. shows ripple down counter, using negative edge triggered J-K FFs and its timing
diagram.
For down counting, Q1' of FF1 is connected to the clock of Ff2. Let initially all the FF1
toggles, so, Q1 goes from a 0 to a 1 and Q1' goes from a 1 to a 0.●
●
●
The negative-going signal at Q1' is applied to the clock input of FF2, toggles Ff2 and,
therefore, Q2 goes from a 0 to a 1.so, after one clock pulse Q2=1 and Q1=1, I.e., the state
of the counter is 11.
At the negative-going edge of the second clock pulse, Q1 changes from a 1 to a 0 and
Q1' from a 0 to a 1.
●
This positive-going signal at Q1' does not affect FF2 and, therefore, Q2 remains at a 1.
Hence, the state of the counter after second clock pulse is 10
At the negative going edge of the third clock pulse, FF1 toggles. So Q1, goes from a 0 to
a 1 and Q1' from 1 to 0. This negative going signal at Q1' toggles FF2 and, so, Q2
changes from 1 to 0, hence, the state of the counter after the third clock pulse is 01.
At the negative going edge of the fourth clock pulse, FF1 toggles. So Q1, goes from a 1
to a 0 and Q1' from 0 to 1.. This positive going signal at Q1' does not affect FF2 and, so,
Q2 remains at 0, hence, the state of the counter after the fourth clock pulse is 00.
Two-bit ripple up-down counter using negative edge triggered flip flop:
Up/Down
Clock
VED
K
O
K
Figure: asynchronous 2-bit ripple up-down counter using negative edge triggered flip flop:
As the name indicates an up-down counter is a counter which can count both in upward
and downward directions. An up-down counter is also called a forward/backward counter
or a bidirectional counter. So, a control signal or a mode signal M is required to choose
the direction of count. When M=1 for up counting, Q1 is transmitted to clock of FF2 and
when M=0 for down counting, Q1' is transmitted to clock of FF2. This is achieved by
using two AND gates and one OR gates. The external clock signal is applied to FF1.
Clock signal to FF2= (Q1.Up)+(Q1'. Down)=Q1m+Q1 'M'
Design of Asynchronous counters:
To design a asynchronous counter, first we write the sequence, then tabulate the values of
reset signal R for various states of the counter and obtain the minimal expression for R and R
using K-Map or any other method. Provide a feedback such that R and R' resets all the FF's after
the desired countDesign of a Mod-6 asynchronous counter using T FFs:
A mod-6 counter has six stable states 000, 001, 010, 011, 100, and 101. When the sixth
clock pulse is applied, the counter temporarily goes to 110 state, but immediately resets to 000
because of the feedback provided. it is divide by-6-counter, in the sense that it divides the
input clock frequency by 6.it requires three FFs, because the smallest value of n satisfying the
conditionN≤2" is n=3; three FFs can have 8 possible states, out of which only six are utilized and
the remaining two states 110and 111, are invalid. If initially the counter is in 000 state, then after
the sixth clock pulse, it goes to 001, after the second clock pulse, it goes to 010, and so on.
CLK
1
T1
Therefore,
Q1
FF1
Q1'
CLR
Clock
Q1
Q2
Q3
R'
1
T2
Q2
The truth table is as shown in below.
FF2
Q2'
CLR
1
T3
Q3
FF3
Q3'
CLR
After sixth clock pulse it goes to 000. For the design, write the truth table with present state
outputs Q3, Q2 and Q1 as the variables, and reset R as the output and obtain an expression for R
in terms of Q3, Q2, and Q1that decides the feedback into be provided. From the truth table,
R=Q3Q2. For active-low Reset, R' is used. The reset pulse is of very short duration, of the order
of nanoseconds and it is equal to the propagation delay time of the NAND gate used. The
expression for R can also be determined as follows.
R=0 for 000 to 101, R=1 for 110, and R=X=for111
R=Q3Q2Q1¹+Q3Q2Q1-Q3Q2
The logic diagram and timing diagram of Mod-6 counter is shown in the above fig.
R'CLK
T1
Q1
FF1
After
pulses
Q1'
0
1
2
CLR
7
States
Q3 Q2 Q1
0 0
0
0
0
1
0
1
1
1
0
0
Design of a mod-10 asynchronous counter using T-flip-flops:
A mod-10 counter is a decade counter. It also called a BCD counter or a divide-by-10
counter. It requires four flip-flops (condition 10 ≤2" is n=4). So, there are 16 possible states, out
of which ten are valid and remaining six are invalid. The counter has ten stable state, 0000
through 1001, i.e., it counts from 0 to 9. The initial state is 0000 and after nine clock pulses it
goes to 1001. When the tenth clock pulse is applied, the counter goes to state 1010 temporarily,
but because of the feedback provided, it resets to initial state 0000. So, there will be a glitch in
the waveform of Q2. The state 1010 is a temporary state for which the reset signal R=1, R=0 for
0000 to 1001, and R=C for 1011 to 1111.
Q2
T1
-340-34
14
FF2
22'
CLR
0 0
0
T2
0
1
0
1
0
1
Q3
FF3
Q3'
R
0
0
0
0
0
0
CLR
0
0
тз 04
Q4'
CLR
R'
The count table and the K-Map for reset are shown in fig. from the K-Map R=Q4Q2. So,
feedback is provided from second and fourth FFs. For active -HIGH reset, Q4Q2 is applied to
the clear terminal. For active-LOW reset 4 2 is connected isof all Flip-flops.Q4Q3
CLK
00
01
11
10
Synchronous counters:
HIGH
Q2Q1
00 01 11 10
FFO
Jo
X X X X
XX
1
C
Ko
20
FF1
J₁
After
pulses
0
C
1
2
K₁
6819455
10
Count
Q4 Q3 Q2 Q1
0
Asynchronous counters are serial counters. They are slow because each FF can change state
only if all the preceding FFs have changed their state. if the clock frequency is very high, the
asynchronous counter may skip some of the states. This problem is overcome in synchronous
counters or parallel counters. Synchronous counters are counters in which all the flip flops are
triggered simultaneously by the clock pulses Synchronous counters have a common clock pulse
applied simultaneously to all flip-flops. A 2-Bit Synchronous Binary Counter
0
0
0
의 CLK
104
Q₁
2₁
0
1
0
0
oooo-0--0-0
2000-1000
11010101010
1
1
2
Design of synchronous counters:
For a systematic design of synchronous counters. The following procedure is used.
Step 1: State Diagram: draw the state diagram showing all the possible states state diagram which
also be called nth transition diagrams, is a graphical means of depicting the sequence of states
through which the counter progresses.
Step2: ber of flip-flops: based on the description of the problem, determine the required
number n of the flip-flops- the smallest value of n is such that the number of states N≤2¹--- and
the desired counting sequence.
Step3: choice of flip-flops excitation table: select the type of flip-flop to be used and write the
excitation table. An excitation table is a table that lists the present state (ps), the next state(ns)
and required excitations.Step4: minimal expressions for excitations: obtain the minimal expressions for the excitations of
the FF using K-maps drawn for the excitation of the flip-flops in terms of the present states and
inputs.
Step5: logic diagram: draw a logic diagram based on the minimal expressions
Design of a synchronous 3-bit up-down counter using JK flip-flops:
Step 1: determine the number of flip-flops required. A 3-bit counter requires three FFs. It has 8
states (000,001,010,011,101,110,111) and all the states are valid. Hence no don't cares. For
selecting up and down modes, a control or mode signal M is required. When the mode signal
M=1 and counts down when M=0. The clock signal is applied to all the FFs simultaneously.
Step2: draw the state diagrams: the state diagram of the 3-bit up-down counter is drawn as
Step 3: select the type of flip flop and draw the excitation table: JK flip-flops are selected and the
excitation table of a 3-bit up-down counter using JK flip-flops is drawn as shown in fig.
PS
Q3
0
0
0
0
0
0
0
0
1
1
1
1
1
1
1
1
Q2
0 0
0
0
0
1
0
1
1
0
1
0
1
1
1
1
0
0
0
0
0
1
0
1
1
0
1
0
1
1
1
Q1
mode NS
M
0
0
1
0
1
0
1
0
1
0
1
0
1
0
Q3 Q2 Q1
1
1
0
0
0
0
0
1
0
0
0
1
0
1
1
0
1
0
0
1
0
1
1
0
0
1
1
1
1
1
1
required excitations
J3
1 1 X
1
0
X
0
0
X
0
0 X
1
0
X
1
0
X
0
0
0
1
1
1
0
0
1
1
0
0
X
X
X
X
X
0
0
X 0
1
X
K3 J2 K2 J1 K1
1 X
1
X
0
X
1
X
0 X
X
1
X
X
X
X
1
0
0
1
X
X
X
1
0
0
0
X
X
X
X
X
1
0
0
1
X
X
X
X
1
0
0
X
1
1
X
X
1
1
X
X
1
1
X
X
1
1
X
X
1
X
X
1
X
X
1
Step4: obtain the minimal expressions: From the excitation table we can conclude that J1=1 and
K1=1, because all the entries for Jland K1 are either X or 1. The K-maps for J3, K3,J2 and K2
based on the excitation table and the minimal expression obtained from them are shown in fig.00 01 11 10
Q3Q2 QIM
X X
X
UP/DOWN
CLK
Step5: draw the logic diagram: a logic diagram using those minimal expressions can be drawn as
shown in fig.
HIGH
X
Jo
FFO
UP
C
Ko
X
X
20
DOWN
2. UP
000
111
FF1
J₁
C
O DOWN
110
001
FF2
Design of a synchronous modulo-6 gray cod counter:
Step 1: the number of flip-flops: we know that the counting sequence for a modulo-6 gray code
counter is 000, 001, 011, 010, 110, and 111. It requires n=3FFs (N≤2", i.e., 6<2³). 3 FFs can have
011
J2
8 states. So the remaining two states 101 and 100 are invalid. The entries for excitation
corresponding to invalid states are don't cares.
Step2: the state diagram: the state diagram of the mod-6 gray code converter is drawn as shown
in fig.
010
> C
K₂
02₂
lzStep3: type of flip-flop and the excitation table: T flip-flops are selected and the excitation table
of the mod-6 gray code counter using T-flip-flops is written as shown in fig.
A O
A O
1
BC
០០
1
BC
00
0
1
BC
00
1
Step4: The minimal expressions: the K-maps for excitations of FFs T3,T2,and T1 in terms of
outputs of FFs Q3,Q2, and Q1, their minimization and the minimal expressions for excitations
obtained from them are shown if fig
1
PS
Q3
0
0
#
0
1
0
0
0
1
1
BC
01
1
BC
01
O
0
BC
01
Q2 Q1
0
0
1
1
1 0
1 0
1
1
(a) Map for JA
JA
1
X
0
1
4
0201
Q2'01'
(c) Map for JB
JB = AC
Q3.
BC
11
4
X
X
CIK
BC
11
(o) Map for Jc
JC = AB
BC
11
X
X
6
7
6
7
NS
Q3
0
0
0
1
1
0
Q3Q1
Q2'01
T1
CLK
Q1
BC
10
FF1
X
Q1
BC
10
BC
10
0
Q2 Q1
0
1
1
1
1
1
0
1
2
1
0
0
1
0
2
A O
A
1
A O
required
excitations
A 1
T3 T2
0
0
0
1
0
0
1
0
BC
00
X
1
BC
00
X
BC
00
X
0
1
O
1
0
0
1
1
01
1
CLK
BC
01
Q301
Q3'Q2Q1'
TZ
Q2
FF2
its
CLK
Q2
X
T1
1
0
1
0
1
1
(b) Map for KA
KA
1
BC
01
0
FF3
1
T3 Q3
4
(d) Map for Ka
KB A
4
5
Q3'
BC
11
x
4
BC
11
Xx
(f) Map for Kc
Kc A
BC
11
X
X
Step5: the logic diagram: the logic diagram based on those minimal expressions is drawn as
shown in fig.
6
7
6
BC
10
1
BC
10
O
1
BC
10
X
2
2
3
2Design of a synchronous BCD Up-Down counter using FFs:
Step 1: the number of flip-flops: a BCD counter is a mod-10 counter has 10 states (0000 through
1001) and so it requires n=4FFs(N≤2",, i.e., 10<24). 4 FFS can have 16 states. So out of 16 states,
six states (1010 through 1111) are invalid. For selecting up and down mode, a control or mode
signal M is required., it counts up when M=1 and counts down when M=0. The clock signal is
applied to all FFs.
Step2: the state diagram: The state diagram of the mod-10 up-down counter is drawn as shown
in fig.
Step3: types of flip-flops and excitation table: T flip-flops are selected and the excitation table of
the modulo-10 up down counter using T flip-flops is drawn as shown in fig.
The remaining minterms are don't cares(Ed(20,21,22,23,24,25,26,37,28,29,30,31)) from
the excitation table we can see that T1=1 and the expression for T4,T3,T2 are as follows.
T4-Em(0,15,16,19)+d(20,21,22,23,24,25,26,27,28,29,30,31)
T3 Em(7,15,16,8)+d(20,21,22,23,24,25,26,27,28,29,30,31)
T2-Em(3,4,7,8,11,12,15,16)+d(20,21,22,23,24,25,26,27,28,29,30,31)
PS
Q4
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
1
1
1
1
Q3
0 0
0
0
0
0
0
0
0
1
0
1
0
1
0
1
1
0
1
0
1
0
0
1
1
1
Q2
1
1
1
1
1
0
0
0
0
0
0
0
0
Q1
0
0
1
1
0
0
1
1
0
0
1
1
0
0
1
1
0
0
1
1
mode
M
0
1
0
1
0
1
0
1
1
0
1
0
1
0
1
0
1
0
1
NS
Q4
1
0
0
0
0
0
0
0
0
0
0
0
0
0
0
1
0
1
1
0
Q3
0
0
0
0
0
0
0
1
0
1
1
1
1
1
1
0
1
0
0
0
Q2
0
0
0
1
0
1
1
0
0
0
1
0
1
1
0
1
0
0
0
required excitations
T3 T2 Τ1
0
0
0
Q1 T4
1
1
1
0
0
0
0
0
1
0
1
0
0
0
0
0
1
0
1
0
0
0
0 0
1
0
1
0
0
0
0
1
1
1
1
0
0
0
0
1
0
0
0
1
0
0
0
0
1
1
0
0
0
0 1
0
1
0
1
1
1
1
1
0
1
0
1
1
1
1
1
0
1
0
1
1
1
1
1
0
1
0
1
1
1
1
1
0
1
0
1
0
1Step4: The minimal expression: since there are 4 state variables and a mode signal, we require 5
variable kmaps. 20 conditions of Q4Q3Q2Q1M are valid and the remaining 12 combinations are
invalid. So the entries for excitations corresponding to those invalid combinations are don't
cares. Minimizing K-maps for T2 we get
T2= Q4Q1'M+Q4*Q1M+Q2Q1 'M'+Q3Q1 'M'
Step5: the logic diagram: the logic diagram based on the above equation is shown in fig.
Q3 02 Q1 M
03 02 01 M
Q4 Q1M
CLK
Q4 Q1M
Q4 Q1M
Q2 Q1 M
CLK
Q3 01 M
T1
D1
FF1
Q1
FF1
Q1
Q1'
Q1¹
Q4 1 M
Q3 Q₂ Q1
T2
FF2
D2 Q2
FF2
Q2
Q2 '
Q2'
Q3Q2Q1M
Shift register counters:
One of the applications of shift register is that they can be arranged to form several types of
counters. The most widely used shift register counter is ring counter as well as the twisted ring
counter.
T3
Ring counter: this is the simplest shift register counter. The basic ring counter using D flip-
flops is shown in fig. the realization of this counter using JK FFs. The Q output of each stage is
connected to the D flip-flop connected back to the ring counter.
D3
FF3
FF3
Q3
Q3
Q3'
Q3'
T4
FF4
D4 04
FF4
Q4
Q4'
04
FIGURE: logic diagram of 4-bit ring counter using D flip-flops
Only a single 1 is in the register and is made to circulate around the register as long as clock
pulses are applied. Initially the first FF is present to a 1. So, the initial state is 1000, i.e., Q1=1,
Q2=0,Q3=0,Q4-0. After each clock pulse, the contents of the register are shifted to the right by
one bit and Q4 is shifted back to Q1. The sequence repeats after four clock pulses. The numberof distinct states in the ring counter, i.e., the mod of the ring counter is equal to number of FFs
used in the counter. An n-bit ring counter can count only n bits, where as n-bit ripple counter can
count 2 bits. So, the ring counter is uneconomical compared to a ripple counter but has
advantage of requiring no decoder, since we can read the count by simply noting which FF is set.
Since it is entirely a synchronous operation and requires no gates external FFs, it has the further
advantage of being very fast.
Timing diagram:
State
Shift
Pulses
QA
QB
Qc
0
1
O
0
1
0
1
0
2
2
0
0
1
0
3
3
0
0
0
1
4
1
0
0
5
Twisted Ring counter (Johnson counter):
This counter is obtained from a serial-in, serial-out shift register by providing feedback
from the inverted output of the last FF to the D input of the first FF. the Q output of each is
connected to the D input of the next stage, but the Q' output of the last stage is connected to the
D input of the first stage, therefore, the name twisted ring counter. This feedback arrangement
produces a unique sequence of states.
The logic diagram of a 4-bit Johnson counter using D FF is shown in fig. the realization
of the same using J-K FFs is shown in fig.. The state diagram and the sequence table are shown
in figure. The timing diagram of a Johnson counter is shown in figure.
Let initially all the FFs be reset, i.e., the state of the counter be 0000. After each clock
pulse, the level of Q1 is shifted to Q2, the level of Q2to Q3, Q3 to Q4 and the level of Q4'to Q1
and the sequences given in fig.Shift
Pulses
Reset
J
CLK A
K
State
Shift
Pulse
QIA
QA
1
Qc 0
QA O 1
QB 00
1
T
I
0
2
2
QD 0 0
I
T
I
3
3
1
0
J
0
Figure: Johnson counter with JK flip-flops
K
I
CLK B
I
I
I
I
1
1
1
0
1
Qa
4 5
4
5
I
1
Qa
I
1
1
1
1
0
1
1
6
6
J
I
K
0
0
I 1
CLK C
1
7 8
7
8
T
I
I
I
|
0
0
0
ac
1
ac
T
I
I
I
I
1
0
0
0
0
Figure: timing diagram
1
9
I
I
T
I
I
T
I
0
0
2
10
I
I
I
J
T
1
I
CLK D
K
1
3
11
J
1
0 1
QD
4
12
000
QD
3-
QoUNIT- V
Memory structures are crucial in digital design. - ROM, PROM, EPROM, RAM, SRAM, (S)DRAM,
RDRAM,..
MEMORY
All memory structures have an address bus and a data bus - Possibly other control signals to control
output etc. E.g. 4 Bit Address bus with 5 Bit Data Bus ADDR DOUT
There are two types of memories that are used in digital systems:
O Random-access memory (RAM): perform both the write and
read operations.
O Read-only memory(ROM): perform only the read operation.
The read-only memory is a programmable logic device. Other such units are the programmablelogic
array(PLA), the programmable array logic (PAL), and the field-programmable gatearray(FPGA).
Random-Access Memory:
A memory unit stores binary information in groups of bits called words.
byte = 8 bits
●
k address lines
Read
Write
word: = 2 bytes
The communication between a memory and its environment is achieved through data input andoutput
lines, address selection lines, and control lines that specify the direction oftransfer.
●
n data input lines
Memory unit
2k words
n bit per word
n data output lines
Fig. 7-2 Block Diagram of a Memory Unit
In random-access memory, the word locations may be thought of as being separated in space, with
each word occupying one particular location.
In sequential-access memory, the information stored in some medium is not immediately accessible,
but is available only certain intervals of time. A magnetic disk or tape unit is of this type.
In a random-access memory, the access time is always the same regardless of the particular locationof
the word.în a sequential-access memory, the time it takes to access a word depends on the position or the wora
with respect to the reading head position; therefore, the access time is variable.Static RAM
SRAM consists essentially of internal latches that store the binaryinformation.
The stored information remains valid as long as power is applied to the unit.
SRAM is easier to use and has shorter read and write cycles.
Low density, low capacity, high cost, high speed, high power consumption.
Dynamic RAM
DRAM stores the binary information in the form of electric charges oncapacitors.
The capacitors are provided inside the chip by MOS transistors.
The capacitors tends to discharge with time and must be periodically recharged by refreshing the
dynamic memory.
DRAM offers reduced power consumption and larger storage capacity in a single memorychip.
High density, high capacity, low cost, low speed, low power consumption.Memory decoding
AddressL
ines
Memory
Enable
Read/Write
Input
¹0
2x4
Decoder
E
0
1
2
3
Select
S
R
BC
(a) Logic diagram
BC
BC
BC
Input Data
Read/Write
Fig. 7-5 Memory Cell
BC
BC
BC
BC
The equivalent logic of a binary cell that stores one bit of information is shown below.
Read/Write = 0, select = 1, input data to S-R latch
Read/Write = 1, select = 1, output data from S-R latch
-
Output
BC
BC
Input
BC
BC
Output Data
Select
BC
Read/Write
BC
BC
BC
BC
Output
(b) Block diagramProgrammable Logic Array:
The decoder in PROM is replaced by an array of AND gates that can be programmed to
generate any product term of the input variables.
The product terms are then connected to OR gates to provide the sum of products forthe
required Boolean functions.
➤ The output is inverted when the XOR input is connected to 1 (since x 1 = x'). The output
doesn't change and connect to 0 (since x 0 = x).
F1 =
AB'+AC+A'BC'
=
F2 = (AC+BC)'
A
B
B
CCB B'A A'
2
3
4
AB'
AC
BC
A'BC'
0
1
B
Fig. 7-14 PLA with 3 Inputs, 4 Product Terms, and 2 Outputs
F₁
F2A
0
A 1
Table 7-5
PLA Programming Table
AB'
AC
BC
A'BC'
BC
00
1
Product Term
1
01
1
2
3
4
●
Implement the following two Boolean functions with a PLA:
F₁(A, B, C) = (0, 1, 2, 4)
F₂(A, B, C) = Σ(0, 5, 6, 7)
B
11 10
1|0||
000
1
Inputs
ABC
C
F1 = A'B' + A'C' + B'C'
F₁ = (AB+ AC + BC)'
1
1
0
0 10
A
0
A 1
Outputs
(T) (C)
F₁ F₂
1
BC
00
1
0
01
0
1
B
11 10
0
1
0
1
C
F₂= AB+ AC + A'B'C'
F₂ = (A'C + A'B + AB'C')'AB
AC
Both the true and complement of
the functions are simplified in sum
of products.
BC
We can find the same terms from
the group terms of the functions of
F₁, F₁,F₂ and F₂’ which will make
the minimum terms.
Inputs
A B C
1 1
1 1
1 1
4
000
Fig. 7-15 Solution to Example 7-2
F1 = (AB + AC + BC)'
F2 = AB + AC + A'B'C'
A'B'C'
PLA programming table
Product
term
1
2
3
Outputs
(C) (T)
F₁ F2
1
1
1
1
1
1A
B
ส
CCB BA A'
ควา
2
3
4
D
- F1
F2